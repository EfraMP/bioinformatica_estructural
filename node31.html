<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<!--Converted with LaTeX2HTML 2008 (1.71)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Relaci&#243;n entre estructura primaria y terciaria</TITLE>
<META NAME="description" CONTENT="Relaci&#243;n entre estructura primaria y terciaria">
<META NAME="keywords" CONTENT="algoritmos3D">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META NAME="Generator" CONTENT="LaTeX2HTML v2008">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="algoritmos3D.css">

<LINK REL="next" HREF="node32.html">
<LINK REL="previous" HREF="node30.html">
<LINK REL="up" HREF="node30.html">
<LINK REL="next" HREF="node32.html">
<!--google-->
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-22456715-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>
</HEAD>

<BODY >

<DIV CLASS="navigation">
<A NAME="tex2html873"
  HREF="node30.html">
<IMG  ALIGN="BOTTOM" BORDER="0" ALT="previous"
 SRC="./icons//prev.png"></A> 
<A NAME="tex2html879"
  HREF="node30.html">
<IMG  ALIGN="BOTTOM" BORDER="0" ALT="up"
 SRC="./icons//up.png"></A> 
<A NAME="tex2html881"
  HREF="node32.html">
<IMG  ALIGN="BOTTOM" BORDER="0" ALT="next"
 SRC="./icons//next.png"></A> <div><fieldset>Siguiente: <b><A NAME="tex2html882"
  HREF="node32.html">Comparaci&#243;n de estructura terciaria entre</A></b>  Arriba: <b><A NAME="tex2html880"
  HREF="node30.html">Estructura terciaria</A></b>  Anterior: <b><A NAME="tex2html874"
  HREF="node30.html">Estructura terciaria</A></b></fieldset></div></DIV>
<!--End of Navigation Panel-->

<H1><A NAME="SECTION00510000000000000000"></A> <A NAME="3dcons"></A>
<BR>
Relaci&#243;n entre estructura primaria y terciaria
</H1>

<P>
En este trabajo de <A
 HREF="node44.html#Chothia1986">Chothia &amp; Lesk (1986)</A> se analiz&#243;
por vez primera la relaci&#243;n entre la secuencia y la estructura de las prote&#237;nas, que se puede
resumir en esta figura:

<P>

<DIV ALIGN="CENTER"><A NAME="fig:chothia_lesk"></A><A NAME="2490"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figura 5.1:</STRONG>

Correlaci&#243;n no lineal entre la conservaci&#243;n de secuencia y estructura de las prote&#237;nas,
tomada de <A
 HREF="node44.html#Chothia1986">Chothia &amp; Lesk (1986)</A>.
</CAPTION>
<TR><TD><IMG
 WIDTH="380" HEIGHT="356" BORDER="0"
 SRC="img51.png"
 ALT="\begin{figure}\begin{center}
\includegraphics{chothia_lesk}\end{center}\end{figure}"></TD></TR>
</TABLE>
</DIV>

<P>
Este art&#237;culo pionero publica la observaci&#243;n de que a una determinada conservaci&#243;n entre las secuencias A y B,
calculada por medio de un alineamiento, le corresponde una mayor o menor divergencia en la comparaci&#243;n de sus estructuras
terciarias, medida en t&#233;rminos de <A NAME="tex2html210"
  HREF="http://en.wikipedia.org/wiki/Root_mean_square_deviation">desviaciones (RMSD)</A>
en las posiciones de sus residuos, dependiendo de si las mutaciones ocurren en el interior ( <i> core  </i>) o exterior del plegamiento. 

<P>
<P></P>
<DIV ALIGN="CENTER" CLASS="mathdisplay"><!-- MATH
 \begin{equation}
RMSD = \sqrt \frac{\sum_{i=1}^n (equiv_{i}^A - equiv_{i}^B)}{n}
\end{equation}
 -->
<TABLE CLASS="equation" CELLPADDING="0" WIDTH="100%" ALIGN="CENTER">
<TR VALIGN="MIDDLE">
<TD NOWRAP ALIGN="CENTER"><SPAN CLASS="MATH"><IMG
 WIDTH="242" HEIGHT="76" ALIGN="MIDDLE" BORDER="0"
 SRC="img52.png"
 ALT="$\displaystyle RMSD = \sqrt \frac{\sum_{i=1}^n (equiv_{i}^A - equiv_{i}^B)}{n}$"></SPAN></TD>
<TD NOWRAP CLASS="eqno" WIDTH="10" ALIGN="RIGHT">
(<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">1</SPAN>)</TD></TR>
</TABLE></DIV>
<BR CLEAR="ALL"><P></P> 

<P>
Adem&#225;s, &#233;ste y otros trabajos posteriores, como el de <A
 HREF="node44.html#Illergard2009">Illergard <EM>et&nbsp;al.</EM> (2009)</A>,
sugieren que la estructura es una propiedad de las prote&#237;nas que se conserva en mayor medida que la secuencia
durante la historia evolutiva. Lo excepcional es encontrar secuencias parecidas con grandes diferencias
estructurales (<A
 HREF="node44.html#Kosloff2008">Kosloff &amp; Kolodny, 2008</A>).
Volveremos a esta observaci&#243;n muy pronto, pero antes quiero hacer hincapi&#233;
en la correspondencia entre un alineamiento de secuencias de prote&#237;nas, generalmente obtenido mediante programaci&#243;n 
din&#225;mica, y la superposici&#243;n de sus estructuras. Tomemos por ejemplo las coordenadas de dos 
<A NAME="tex2html211"
  HREF="http://scop.berkeley.edu/sunid=53955">lisozimas</A>
del PDB, como
<A NAME="tex2html212"
  HREF="http://www.rcsb.org/pdb/explore/explore.do?structureId=2NWD">2NWD</A>
y 
<A NAME="tex2html213"
  HREF="http://www.rcsb.org/pdb/explore/explore.do?structureId=1GD6">1GD6</A>
(<A NAME="tex2html214"
  HREF="./files/2nwd.pdb">2nwd.pdb</A>,<A NAME="tex2html215"
  HREF="./files/1gd6.pdb">1gd6.pdb</A>), 
y alineemos sus secuencias:
<PRE>
2nwd   KVFERCELARTLKRLGMDGYRGISLANWMCLAKWESGYNTRATNYNAGDRSTDYGIFQIN 60
1gd6   KTFTRCGLVHELRKHGFEEN---LMRNWVCLVEHESSRDTSKTNTNR-NGSKDYGLFQIN 56

2nwd   SRYWCNDGKTPGAVNACHLSCSALLQDNIADAVACAKRVVRDPQGIRAWVAWRNRCQNRD 120
1gd6   DRYWCSKGASPG--KDCNVKCSDLLTDDITKAAKCAKKIYKR-HRFDAWYGWKNHCQG-- 111

2nwd   VRQYVQGCGV 130
1gd6   SLPDISSC-- 119
</PRE>

<P>
Mediante un algoritmo similar al descrito en este trabajo de <A
 HREF="node44.html#McLachlan1979">McLachlan (1979)</A>, que hace uso de la 
<A NAME="tex2html216"
  HREF="http://books.google.es/books?id=I2TEgd8-yfsC&amp;lpg=PR1&amp;pg=PA73#v=onepage&amp;q&amp;f=false">descomposici&#243;n en valores singulares</A>,
podemos calcular la superposici&#243;n correspondiente. El siguiente programa, que importa
el m&#243;dulo <A NAME="tex2html217"
  HREF="./files/SVD.py">SVD</A>, lo implementa:
<BR>
<PRE  CLASS="verbatim">#!/usr/bin/env python
""" prog3.1 Calcula la superposicion en 3D equivalente a un alineamiento de 
secuencia de dos proteinas del PDB. Genera un fichero PDB con la superposicion 
obtenida. """

__author__  = 'Bruno Contreras-Moreira' 

from math import sqrt
import SVD 

# 0) parametros del algoritmo: 
pdb1 = { 'file':'./files/1gd6.pdb', 
	'align':'KTFTRCGLVHELRKHGFEEN---LMRNWVCLVEHESSRDTSKTNTNR-NGSKDYGLFQIN' +
	'DRYWCSKGASPG--KDCNVKCSDLLTDDITKAAKCAKKIYKR-HRFDAWYGWKNHCQG--SLPDISSC--' };

pdb2 = { 'file':'./files/2nwd.pdb', 
	'align':'KVFERCELARTLKRLGMDGYRGISLANWMCLAKWESGYNTRATNYNAGDRSTDYGIFQIN' +
	'SRYWCNDGKTPGAVNACHLSCSALLQDNIADAVACAKRVVRDPQGIRAWVAWRNRCQNRDVRQYVQGCGV' };
	
# 1) subrutinas
def lee_coordenadas_PDB(filename):
	""" Devuelve una lista de residuos, cada uno con las coordenadas de sus atomos. 
	Ejemplo de linea en formato PDB:
	ATOM     42  CA  PHE X   3       6.981  22.274  18.887  1.00  6.72 """
	
	coords = []
	pdbfile = open(filename,'r')
	try:
		res,prev_resID = '',''
		for line in pdbfile:
			if(line[0:3] == 'TER'): break
			if(line[0:4] != 'ATOM'): continue
			resID = line[17:26]
			if(resID != prev_resID):
				if(res != ''): coords.append(res)
				res = line
			else: res += line	
			
			prev_resID = resID
		
		if(res != ''): coords.append(res)		
	finally:
		pdbfile.close()	
	return coords	

def coords_alineadas(align1,coords1,align2,coords2):
	""" Devuelve dos listas de igual longitud con las coordenadas de los atomos CA 
	de los residuos alineados en align1 y align2."""
	
	total1,total2 = -1,-1
	align_coords1,align_coords2 = [],[]
	length = len(align1)
	
	if(length != len(align2)): 
		print "# coords_alineadas: alineamientos tienen != longitud",
		return ([],[])
	
	for r in range(0, length):
		res1 = align1[r:r+1]
		res2 = align2[r:r+1]
		if(res1 != '-'): total1+=1
		if(res2 != '-'): total2+=1
		if(res1 == '-' or res2 == '-'): continue #solo  interesan pares alineados
		align_coords1.append( extrae_coords_atomo(coords1[total1],' CA ') )
		align_coords2.append( extrae_coords_atomo(coords2[total2],' CA ') )
	return (align_coords1,align_coords2)
	
def extrae_coords_atomo(res,atomo_seleccion):
	""" De todas las coordenadas atomicas de un residuo, extrae las de un atomo particular 
	y devuelve una lista con las X, Y y Z de ese atomo."""
	
	atom_coords = []
	for atomo in res.split("\n"):
		if(atomo[12:16] == atomo_seleccion):
			atom_coords = [ float(atomo[30:38]), float(atomo[38:46]), float(atomo[46:54]) ]
	return atom_coords
	

def calcula_superposicion_SVD(pdbh1,pdbh2,originalPDBname,fittedPDBname,test=False):
	""" Calcula matriz de rotacion que aplicada sobre coords1 minimiza RMSD respecto a coords2
	y crea archivo con formato PDB con la superposicion resultante.
	Emplea el algoritmo de 'Single Value Decomposition' del paquete SVD. """
	
	def calcula_centro(coords):
		centro = [0,0,0]
    		for coord in (coords): 
			for dim in range(0,3): centro[dim] += coord[dim]
    		for dim in range(0,3): centro[dim] /= len(coords)
		return centro
   
   	def calcula_coordenadas_centradas(coords,centro):
		ccoords,total = [],0
		for coord in (coords): 
			ccoords.append(coord)
			for dim in range(0,3): ccoords[total][dim] -= centro[dim]
			total+=1
		return ccoords
		
	def calcula_coordenadas_rotadas(coords,rotacion):
		rcoords = [0,0,0]            
		for i in range(0,3):               
			tmp = 0.0
			for j in range(0,3): tmp += coords[j] * rotacion[i][j]
			rcoords[i] = tmp
		return rcoords			
   
   	# escribe fichero PDB con coordenadas originales
	pdbfile = open(originalPDBname, 'w')
	print &gt;&gt; pdbfile, "HEADER %s\n" % pdbh1['file'],
	for res in (pdbh1['coords']): print &gt;&gt; pdbfile, res,
	print &gt;&gt; pdbfile, "TER\n",
	print &gt;&gt; pdbfile, "HEADER %s\n" % pdbh2['file'],
	for res in (pdbh2['coords']): print &gt;&gt; pdbfile, res,
	print &gt;&gt; pdbfile, "TER\n",
	pdbfile.close()	
	
	## prepara coordenadas de atomos CA alineados (equivalentes)
	coords1,coords2 = pdbh1['align_coords'],pdbh2['align_coords']
    	centro1 = calcula_centro(coords1) 
    	centro2 = calcula_centro(coords2) 
	ccoords1 = calcula_coordenadas_centradas(coords1,centro1) 
	ccoords2 = calcula_coordenadas_centradas(coords2,centro2) 
	
	## prepara matriz producto para descomposicion matricial SVD matriz = U.Sigma.V
	matriz = [[0,0,0],[0,0,0],[0,0,0]]
	peso = 1.0/len(ccoords1) # todos los residuos cuentan igual
	for i in range(0,3):
		for j in range(0,3):
			tmp = 0.0
			for k in range(0,len(ccoords1)): tmp += ccoords1[k][i] * ccoords2[k][j] * peso
			matriz[i][j]=tmp;
	if(test == True): 
		for i in range(0,3): print "mat %f %f %f\n" % (matriz[i][0],matriz[i][1],matriz[i][2]),		
   			
	## invoca descomposicion en valores singulares y comprueba matrix/determinante
	[U, Sigma, V] = SVD.svd( matriz )
	if(test==True): 
		for i in range(0,3): print "U %f %f %f\n" % (U[i][0],U[i][1],U[i][2]),
		for i in range(0,3): print "Vt %f %f %f\n" % (V[i][0],V[i][1],V[i][2]),
	
	rotacion = [[0,0,0],[0,0,0],[0,0,0]]
	for i in range(0,3):
		for j in range(0,3):
			rotacion[i][j]= U[j][0]*V[i][0] + U[j][1]*V[i][1] + U[j][2]*V[i][2]
				
	## evalua error de la superposicion
	rmsd = 0.0
	for n in range(0,len(coords1)):
		coords1_rot = calcula_coordenadas_rotadas(ccoords1[n],rotacion)
		for i in range(0,3):
			desv = ccoords2[n][i]-coords1_rot[i]
			rmsd += desv*desv
   	rmsd /= len(coords1)
	
	## imprime superposicion de todos los atomos en formato PDB
	pdbfile = open(fittedPDBname, 'w')
	
	# pdb superpuesto, coordenadas rotadas (1)
	print &gt;&gt; pdbfile, "HEADER %s (rotated)\n" % pdbh1['file'],
	print &gt;&gt; pdbfile, "REMARK Rotation matrix:\n",
	for i in range(0,3): print &gt;&gt; pdbfile, "REMARK %f %f %f\n" % \
				(rotacion[i][0],rotacion[i][1],rotacion[i][2]),
	print &gt;&gt; pdbfile, "REMARK centroid: %f %f %f\n" % (centro1[0],centro1[1],centro1[2]),
	print &gt;&gt; pdbfile, "REMARK partner centroid: %f %f %f\n" % \
		(centro2[0],centro2[1],centro2[2]),
	for res in (pdbh1['coords']): 
		for atomo in res.split("\n"):
			if(atomo == ''): break
			atcoords = extrae_coords_atomo(res,atomo[12:16]) 
			
			atcoords[0] -= centro1[0] # centralo
			atcoords[1] -= centro1[1]
			atcoords[2] -= centro1[2]
			
			coords_rot = calcula_coordenadas_rotadas(atcoords,rotacion)
			
			# trasladalo al pdb referencia
			atcoords[0] = centro2[0] + coords_rot[0] 
			atcoords[1] = centro2[1] + coords_rot[1]
			atcoords[2] = centro2[2] + coords_rot[2]
					
			print &gt;&gt; pdbfile, "%s%8.3f%8.3f%8.3f%s" % \
			(atomo[0:30],atcoords[0],atcoords[1],atcoords[2],atomo[54:])	
	print &gt;&gt; pdbfile, "TER\n",	
	
	# pdb de referencia, coordenadas originales (2)
	print &gt;&gt; pdbfile, "HEADER %s\n" % pdbh2['file'],
	for res in (pdbh2['coords']): print &gt;&gt; pdbfile, res,
	print &gt;&gt; pdbfile, "TER\n",
	
	pdbfile.close()	
	
	return sqrt(rmsd)
					

# 2) programa principal ###################################################

pdb1['coords'] = lee_coordenadas_PDB( pdb1['file'] )
pdb2['coords'] = lee_coordenadas_PDB( pdb2['file'] )
		
print "# total residuos: pdb1 = %s pdb2 = %s\n" % (len(pdb1['coords']),len(pdb2['coords'])),

(pdb1['align_coords'],pdb2['align_coords']) = coords_alineadas(pdb1['align'],pdb1['coords'],\
						pdb2['align'],pdb2['coords'] )

print "# total residuos alineados = %s\n" % (len(pdb1['align_coords'])),

rmsd = calcula_superposicion_SVD(pdb2,pdb1,'original.pdb','align_fit.pdb')

print "\n# coordenadas originales = original.pdb\n# superposicion optima:\n", 
print "# archivo PDB = align_fit.pdb\n# RMSD = %1.2f Angstrom\n" % (rmsd),
</PRE>
<P>
Si cambias el alineamiento ver&#225;s que cambia la superposici&#243;n, demostrando la importancia que tiene la 
variable 'calidad de los alineamientos' si vamos a hacer inferencias estructurales. Sabr&#237;as editar el c&#243;digo
para replicar el algoritmo de superposici&#243;n de <A
 HREF="node44.html#Chothia1986">Chothia &amp; Lesk (1986)</A>?

<P>

<DIV CLASS="navigation"><hr> 
<A NAME="tex2html873"
  HREF="node30.html">
<IMG  ALIGN="BOTTOM" BORDER="0" ALT="previous"
 SRC="./icons//prev.png"></A> 
<A NAME="tex2html879"
  HREF="node30.html">
<IMG  ALIGN="BOTTOM" BORDER="0" ALT="up"
 SRC="./icons//up.png"></A> 
<A NAME="tex2html881"
  HREF="node32.html">
<IMG  ALIGN="BOTTOM" BORDER="0" ALT="next"
 SRC="./icons//next.png"></A> </DIV>
<!--End of Navigation Panel-->
<ADDRESS>
<a href="http://hdl.handle.net/10261/21892">PDF</a><br>Bruno Contreras-Moreira<br><a href="http://www.eead.csic.es/compbio">http://www.eead.csic.es/compbio</a>
</ADDRESS>
</BODY>
</HTML>
