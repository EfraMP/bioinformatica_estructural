<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<!--Converted with LaTeX2HTML 2018.2 (Released May 16, 2018) -->
<HTML>
<HEAD>
<TITLE>Relaci&#243;n entre estructura primaria y terciaria de las prote&#237;nas: alineamientos y superposiciones</TITLE>
<META NAME="description" CONTENT="Relaci&#243;n entre estructura primaria y terciaria de las prote&#237;nas: alineamientos y superposiciones">
<META NAME="keywords" CONTENT="algoritmos3D">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META NAME="Generator" CONTENT="LaTeX2HTML v2018.2">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="algoritmos3D.css">

<LINK REL="previous" HREF="node11.html">
<LINK REL="up" HREF="node7.html">
<LINK REL="next" HREF="node13.html">
<!--google-->
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-22456715-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>
</HEAD>

<BODY >

<DIV CLASS="navigation">
<A NAME="tex2html782"
  HREF="node11.html">
<IMG  ALIGN="BOTTOM" BORDER="0" ALT="previous"
 SRC="./icons//prev.png"></A> 
<A NAME="tex2html786"
  HREF="node7.html">
<IMG  ALIGN="BOTTOM" BORDER="0" ALT="up"
 SRC="./icons//up.png"></A> 
<A NAME="tex2html788"
  HREF="node13.html">
<IMG  ALIGN="BOTTOM" BORDER="0" ALT="next"
 SRC="./icons//next.png"></A> <div><fieldset>Siguiente: <b><A NAME="tex2html789"
  HREF="node13.html">M&#233;todos experimentales para el estudio</A></b>  Arriba: <b><A NAME="tex2html787"
  HREF="node7.html">An&#225;lisis jer&#225;rquico de la estructura</A></b>  Anterior: <b><A NAME="tex2html783"
  HREF="node11.html">Estructura 3D de la cromatina</A></b></fieldset></div></DIV>
<!--End of Navigation Panel-->

<H2><A NAME="SECTION00135000000000000000"></A> <A NAME="3dcons"></A>
<BR>
Relaci&#243;n entre estructura primaria y terciaria de las prote&#237;nas: alineamientos y superposiciones
</H2>

<P>
<A
 HREF="node50.html#Chothia1986">Chothia &amp; Lesk (1986)</A> analizaron por vez primera la relaci&#243;n entre la secuencia y la estructura de las prote&#237;nas, 
que se puede resumir en esta figura:

<P>

<DIV ALIGN="CENTER"><A NAME="fig:chothia_lesk"></A><A NAME="1012"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figura 1.28:</STRONG>

Correlaci&#243;n no lineal entre la conservaci&#243;n de secuencia y estructura de las prote&#237;nas,
tomada de <A
 HREF="node50.html#Chothia1986">Chothia &amp; Lesk (1986)</A> y reproducida con permiso de los autores.
</CAPTION>
<TR><TD><IMG
 WIDTH="380" HEIGHT="356" BORDER="0"
 SRC="img23.png"
 ALT="\begin{figure}\begin{center}
\includegraphics{chothia_lesk}\end{center}\end{figure}"></TD></TR>
</TABLE>
</DIV>

<P>
Este art&#237;culo pionero publica la observaci&#243;n de que a una determinada conservaci&#243;n entre las secuencias A y B,
calculada por medio de un alineamiento, le corresponde una mayor o menor divergencia en la comparaci&#243;n de sus estructuras
terciarias, medida en t&#233;rminos de <A NAME="tex2html128"
  HREF="http://en.wikipedia.org/wiki/Root_mean_square_deviation">desviaciones (RMSD, en Angstrom)</A>
en las posiciones de sus residuos, dependiendo de si las mutaciones ocurren en el interior ( <i> core  </i>) o exterior del plegamiento. 

<P>
<P></P>
<DIV ALIGN="CENTER" CLASS="mathdisplay"><!-- MATH
 \begin{equation}
RMSD = \sqrt \frac{\sum_{i=1}^n dist(C\alpha_{i}^A - C\alpha_{i}^B)^2}{n}
\end{equation}
 -->
<TABLE CLASS="equation" CELLPADDING="0" WIDTH="100%" ALIGN="CENTER">
<TR VALIGN="MIDDLE">
<TD NOWRAP ALIGN="CENTER"><SPAN CLASS="MATH"><IMG
 WIDTH="285" HEIGHT="87" ALIGN="MIDDLE" BORDER="0"
 SRC="img24.png"
 ALT="$\displaystyle RMSD = \sqrt \frac{\sum_{i=1}^n dist(C\alpha_{i}^A - C\alpha_{i}^B)^2}{n}$"></SPAN></TD>
<TD NOWRAP CLASS="eqno" WIDTH="10" ALIGN="RIGHT">
(<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">1</SPAN>)</TD></TR>
</TABLE></DIV>
<BR CLEAR="ALL"><P></P> 

<P>
Adem&#225;s, &#233;ste y otros trabajos posteriores, como <A NAME="tex2html790" target="contents"
  HREF="node50.html#PascualGarcia2010">Pascual-Garcia <EM>et&nbsp;al.</EM> (2010)</A>; <A NAME="tex2html791" target="contents"
  HREF="node50.html#Illergard2009">Illergard <EM>et&nbsp;al.</EM> (2009)</A>,
sugieren que la estructura es una propiedad de las prote&#237;nas que se conserva en mayor medida que la secuencia
durante la historia evolutiva. Lo excepcional es que secuencias similares tengan grandes diferencias estructurales (<A
 HREF="node50.html#Kosloff2008">Kosloff &amp; Kolodny, 2008</A>).

<P>

<DIV ALIGN="CENTER"><A NAME="fig:thioredoxins"></A><A NAME="1014"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figura 1.29:</STRONG>

Conservaci&#243;n de la estructura de tioredoxinas separadas 4 mil millones de a&#241;os.
(A) &#193;rbol filogen&#233;tico moestrando la distancia evolutiva entre H. sapiens y E. coli y algunos de sus ancestros desaparecidos.
(B) Superposici&#243;n estructural de varias tioredoxinas humanas, de E. coli, y de algunos ancestros prec&#225;mbricos.
(C) Alineamiento m&#250;ltiple de las secuencias y estructuras secundarias de las tioredoxinas estudiadas.
Figura reproducida con permiso de <A
 HREF="node50.html#InglesPrieto2013">Ingles-Prieto <EM>et&nbsp;al.</EM> (2013)</A>.
</CAPTION>
<TR><TD>
<DIV ALIGN="CENTER">
<IMG
  WIDTH="769" HEIGHT="588" ALIGN="BOTTOM" BORDER="0"
 SRC="./thioredoxins.jpg"
 ALT="Image thioredoxins">

</DIV></TD></TR>
</TABLE>
</DIV>

<P>
El panel C de la figura <A HREF="#fig:thioredoxins">1.29</A> es &#250;til para recordar la correspondencia que se puede establecer 
entre un <SPAN  CLASS="textbf">alineamiento</SPAN> de secuencias y la <SPAN  CLASS="textbf">superposici&#243;n</SPAN> de las correspondientes estructuras. 
En un alineamiento de secuencia se establece qu&#233; residuos de una prote&#237;na ocupan el mismo lugar en la secuencia
que los de otras prote&#237;nas similares. 
En cambio, en una superposici&#243;n buscamos residuos que ocupan el mismo lugar en la estructura, a los que llamamos  
<SPAN  CLASS="textbf">residuos equivalentes</SPAN>.
Mientras el primero se puede calcular aun sin tener las estructuras, solamente con la secuencia, la superposici&#243;n
requiere conocer las coordenadas en tres dimensiones de las prote&#237;nas en cuesti&#243;n.
Con aquellas prote&#237;nas con estructuras resueltas es posible hacer el siguiente ejercicio,
que tiene como objeto explorar esta correspondencia y aprender que un alineamiento de secuencias con baja identidad
puede contener errores que se hacen patentes al comprobar la correspondiente superposici&#243;n.

<P>
Tomemos por ejemplo las coordenadas de dos 
<A NAME="tex2html129"
  HREF="http://scop.berkeley.edu/sunid=53955">lisozimas</A>
del PDB, como
<A NAME="tex2html130"
  HREF="http://www.rcsb.org/pdb/explore/explore.do?structureId=2NWD">2NWD</A>
y 
<A NAME="tex2html131"
  HREF="http://www.rcsb.org/pdb/explore/explore.do?structureId=1GD6">1GD6</A>
(<A NAME="tex2html132"
  HREF="./files/2nwd.pdb">2nwd.pdb</A>,<A NAME="tex2html133"
  HREF="./files/1gd6.pdb">1gd6.pdb</A>), 
y alineemos sus secuencias:
<PRE>
2nwd   KVFERCELARTLKRLGMDGYRGISLANWMCLAKWESGYNTRATNYNAGDRSTDYGIFQIN 60
1gd6   KTFTRCGLVHELRKHGFEEN---LMRNWVCLVEHESSRDTSKTNTNR-NGSKDYGLFQIN 56

2nwd   SRYWCNDGKTPGAVNACHLSCSALLQDNIADAVACAKRVVRDPQGIRAWVAWRNRCQNRD 120
1gd6   DRYWCSKGASPG--KDCNVKCSDLLTDDITKAAKCAKKIYKR-HRFDAWYGWKNHCQG-- 111

2nwd   VRQYVQGCGV 130
1gd6   SLPDISSC-- 119
</PRE>

<P>
En este alineamiento las columnas alineadas son parejas de residuos equivalentes o
inserciones/deleciones sin alinear (<SPAN  CLASS="textbf">indels</SPAN>).

<P>
Mediante un algoritmo similar al descrito en este trabajo de <A
 HREF="node50.html#McLachlan1979">McLachlan (1979)</A>, que hace uso de la 
<A NAME="tex2html134"
  HREF="http://books.google.es/books?id=I2TEgd8-yfsC&amp;lpg=PR1&amp;pg=PA73#v=onepage&amp;q&amp;f=false">descomposici&#243;n en valores singulares</A>,
podemos calcular la superposici&#243;n correspondiente. El siguiente programa, que importa
el m&#243;dulo <A NAME="tex2html135"
  HREF="./files/SVD.py">SVD</A>, lo implementa:
<BR>
<PRE  CLASS="verbatim">#!/usr/bin/env python
""" prog3.1 Calcula la superposicion en 3D equivalente a un alineamiento de 
secuencia de dos proteinas del PDB. Genera un fichero PDB con la superposicion 
obtenida. """

__author__  = 'Bruno Contreras-Moreira' 

from math import sqrt
import SVD 

# 0) parametros del algoritmo: 
pdb1 = { 'file':'./files/1gd6.pdb', 
	'align':'KTFTRCGLVHELRKHGFEEN---LMRNWVCLVEHESSRDTSKTNTNR-NGSKDYGLFQIN' +
	'DRYWCSKGASPG--KDCNVKCSDLLTDDITKAAKCAKKIYKR-HRFDAWYGWKNHCQG--SLPDISSC--' };

pdb2 = { 'file':'./files/2nwd.pdb', 
	'align':'KVFERCELARTLKRLGMDGYRGISLANWMCLAKWESGYNTRATNYNAGDRSTDYGIFQIN' +
	'SRYWCNDGKTPGAVNACHLSCSALLQDNIADAVACAKRVVRDPQGIRAWVAWRNRCQNRDVRQYVQGCGV' };
	
# 1) subrutinas
def lee_coordenadas_PDB(filename):
	""" Devuelve una lista de residuos, cada uno con las coordenadas de sus atomos. 
	Ejemplo de linea en formato PDB:
	ATOM     42  CA  PHE X   3       6.981  22.274  18.887  1.00  6.72 """
	
	coords = []
	pdbfile = open(filename,'r')
	try:
		res,prev_resID = '',''
		for line in pdbfile:
			if(line[0:3] == 'TER'): break
			if(line[0:4] != 'ATOM'): continue
			resID = line[17:26]
			if(resID != prev_resID):
				if(res != ''): coords.append(res)
				res = line
			else: res += line	
			
			prev_resID = resID
		
		if(res != ''): coords.append(res)		
	finally:
		pdbfile.close()	
	return coords	

def coords_alineadas(align1,coords1,align2,coords2):
	""" Devuelve dos listas de igual longitud con las coordenadas de los atomos CA 
	de los residuos alineados en align1 y align2."""
	
	total1,total2 = -1,-1
	align_coords1,align_coords2 = [],[]
	length = len(align1)
	
	if(length != len(align2)): 
		print "# coords_alineadas: alineamientos tienen != longitud",
		return ([],[])
	
	for r in range(0, length):
		res1 = align1[r:r+1]
		res2 = align2[r:r+1]
		if(res1 != '-'): total1+=1
		if(res2 != '-'): total2+=1
		if(res1 == '-' or res2 == '-'): continue #solo  interesan pares alineados
		align_coords1.append( extrae_coords_atomo(coords1[total1],' CA ') )
		align_coords2.append( extrae_coords_atomo(coords2[total2],' CA ') )
	return (align_coords1,align_coords2)
	
def extrae_coords_atomo(res,atomo_seleccion):
	""" De todas las coordenadas atomicas de un residuo, extrae las de un atomo particular 
	y devuelve una lista con las X, Y y Z de ese atomo."""
	
	atom_coords = []
	for atomo in res.split("\n"):
		if(atomo[12:16] == atomo_seleccion):
			atom_coords = [ float(atomo[30:38]), float(atomo[38:46]), float(atomo[46:54]) ]
	return atom_coords
	

def calcula_superposicion_SVD(pdbh1,pdbh2,originalPDBname,fittedPDBname,test=False):
	""" Calcula matriz de rotacion que aplicada sobre coords1 minimiza RMSD respecto a coords2
	y crea archivo con formato PDB con la superposicion resultante.
	Emplea el algoritmo de 'Single Value Decomposition' del paquete SVD. """
	
	def calcula_centro(coords):
		centro = [0,0,0]
    		for coord in (coords): 
			for dim in range(0,3): centro[dim] += coord[dim]
    		for dim in range(0,3): centro[dim] /= len(coords)
		return centro
   
   	def calcula_coordenadas_centradas(coords,centro):
		ccoords,total = [],0
		for coord in (coords): 
			ccoords.append(coord)
			for dim in range(0,3): ccoords[total][dim] -= centro[dim]
			total+=1
		return ccoords
		
	def calcula_coordenadas_rotadas(coords,rotacion):
		rcoords = [0,0,0]            
		for i in range(0,3):               
			tmp = 0.0
			for j in range(0,3): tmp += coords[j] * rotacion[i][j]
			rcoords[i] = tmp
		return rcoords			
   
   	# escribe fichero PDB con coordenadas originales
	pdbfile = open(originalPDBname, 'w')
	print &gt;&gt; pdbfile, "HEADER %s\n" % pdbh1['file'],
	for res in (pdbh1['coords']): print &gt;&gt; pdbfile, res,
	print &gt;&gt; pdbfile, "TER\n",
	print &gt;&gt; pdbfile, "HEADER %s\n" % pdbh2['file'],
	for res in (pdbh2['coords']): print &gt;&gt; pdbfile, res,
	print &gt;&gt; pdbfile, "TER\n",
	pdbfile.close()	
	
	## prepara coordenadas de atomos CA alineados (equivalentes)
	coords1,coords2 = pdbh1['align_coords'],pdbh2['align_coords']
    	centro1 = calcula_centro(coords1) 
    	centro2 = calcula_centro(coords2) 
	ccoords1 = calcula_coordenadas_centradas(coords1,centro1) 
	ccoords2 = calcula_coordenadas_centradas(coords2,centro2) 
	
	## prepara matriz producto para descomposicion matricial SVD matriz = U.Sigma.V
	matriz = [[0,0,0],[0,0,0],[0,0,0]]
	peso = 1.0/len(ccoords1) # todos los residuos cuentan igual
	for i in range(0,3):
		for j in range(0,3):
			tmp = 0.0
			for k in range(0,len(ccoords1)): tmp += ccoords1[k][i] * ccoords2[k][j] * peso
			matriz[i][j]=tmp;
	if(test == True): 
		for i in range(0,3): print "mat %f %f %f\n" % (matriz[i][0],matriz[i][1],matriz[i][2]),		
   			
	## invoca descomposicion en valores singulares y comprueba matrix/determinante
	[U, Sigma, V] = SVD.svd( matriz )
	if(test==True): 
		for i in range(0,3): print "U %f %f %f\n" % (U[i][0],U[i][1],U[i][2]),
		for i in range(0,3): print "Vt %f %f %f\n" % (V[i][0],V[i][1],V[i][2]),
	
	rotacion = [[0,0,0],[0,0,0],[0,0,0]]
	for i in range(0,3):
		for j in range(0,3):
			rotacion[i][j]= U[j][0]*V[i][0] + U[j][1]*V[i][1] + U[j][2]*V[i][2]
				
	## evalua error de la superposicion
	rmsd = 0.0
	for n in range(0,len(coords1)):
		coords1_rot = calcula_coordenadas_rotadas(ccoords1[n],rotacion)
		for i in range(0,3):
			desv = ccoords2[n][i]-coords1_rot[i]
			rmsd += desv*desv
   	rmsd /= len(coords1)
	
	## imprime superposicion de todos los atomos en formato PDB
	pdbfile = open(fittedPDBname, 'w')
	
	# pdb superpuesto, coordenadas rotadas (1)
	print &gt;&gt; pdbfile, "HEADER %s (rotated)\n" % pdbh1['file'],
	print &gt;&gt; pdbfile, "REMARK Rotation matrix:\n",
	for i in range(0,3): print &gt;&gt; pdbfile, "REMARK %f %f %f\n" % \
				(rotacion[i][0],rotacion[i][1],rotacion[i][2]),
	print &gt;&gt; pdbfile, "REMARK centroid: %f %f %f\n" % (centro1[0],centro1[1],centro1[2]),
	print &gt;&gt; pdbfile, "REMARK partner centroid: %f %f %f\n" % \
		(centro2[0],centro2[1],centro2[2]),
	for res in (pdbh1['coords']): 
		for atomo in res.split("\n"):
			if(atomo == ''): break
			atcoords = extrae_coords_atomo(res,atomo[12:16]) 
			
			atcoords[0] -= centro1[0] # centralo
			atcoords[1] -= centro1[1]
			atcoords[2] -= centro1[2]
			
			coords_rot = calcula_coordenadas_rotadas(atcoords,rotacion)
			
			# trasladalo al pdb referencia
			atcoords[0] = centro2[0] + coords_rot[0] 
			atcoords[1] = centro2[1] + coords_rot[1]
			atcoords[2] = centro2[2] + coords_rot[2]
					
			print &gt;&gt; pdbfile, "%s%8.3f%8.3f%8.3f%s" % \
			(atomo[0:30],atcoords[0],atcoords[1],atcoords[2],atomo[54:])	
	print &gt;&gt; pdbfile, "TER\n",	
	
	# pdb de referencia, coordenadas originales (2)
	print &gt;&gt; pdbfile, "HEADER %s\n" % pdbh2['file'],
	for res in (pdbh2['coords']): print &gt;&gt; pdbfile, res,
	print &gt;&gt; pdbfile, "TER\n",
	
	pdbfile.close()	
	
	return sqrt(rmsd)
					

# 2) programa principal ###################################################

pdb1['coords'] = lee_coordenadas_PDB( pdb1['file'] )
pdb2['coords'] = lee_coordenadas_PDB( pdb2['file'] )
		
print "# total residuos: pdb1 = %s pdb2 = %s\n" % (len(pdb1['coords']),len(pdb2['coords'])),

(pdb1['align_coords'],pdb2['align_coords']) = coords_alineadas(pdb1['align'],pdb1['coords'],\
						pdb2['align'],pdb2['coords'] )

print "# total residuos alineados = %s\n" % (len(pdb1['align_coords'])),

rmsd = calcula_superposicion_SVD(pdb2,pdb1,'original.pdb','align_fit.pdb')

print "\n# coordenadas originales = original.pdb\n# superposicion optima:\n", 
print "# archivo PDB = align_fit.pdb\n# RMSD = %1.2f Angstrom\n" % (rmsd),
</PRE>
<P>
Al cambiar el alineamiento cambia la superposici&#243;n, demostrando la importancia que tiene la 
variable 'calidad de los alineamientos' si vamos a hacer inferencias estructurales. Sabr&#237;as editar el c&#243;digo
para replicar el algoritmo de superposici&#243;n de <A
 HREF="node50.html#Chothia1986">Chothia &amp; Lesk (1986)</A>?

<P>

<DIV CLASS="navigation"><hr> 
<A NAME="tex2html782"
  HREF="node11.html">
<IMG  ALIGN="BOTTOM" BORDER="0" ALT="previous"
 SRC="./icons//prev.png"></A> 
<A NAME="tex2html786"
  HREF="node7.html">
<IMG  ALIGN="BOTTOM" BORDER="0" ALT="up"
 SRC="./icons//up.png"></A> 
<A NAME="tex2html788"
  HREF="node13.html">
<IMG  ALIGN="BOTTOM" BORDER="0" ALT="next"
 SRC="./icons//next.png"></A> </DIV>
<!--End of Navigation Panel-->
<ADDRESS>
<a href="http://hdl.handle.net/10261/21892">PDF</a><br>Contreras-Moreira,B. (2018) Algoritmos en bioinform&aacute;tica estructural. <a href="https://doi.org/10.20350/digitalcsic/8544">doi:10.20350/digitalcsic/8544</a><br><a href="http://www.eead.csic.es/compbio">http://www.eead.csic.es/compbio</a>
</ADDRESS>
</BODY>
</HTML>
