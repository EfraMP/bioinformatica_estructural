<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<!--Converted with LaTeX2HTML 2008 (1.71)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Dise&#241;o de primers para PCR</TITLE>
<META NAME="description" CONTENT="Dise&#241;o de primers para PCR">
<META NAME="keywords" CONTENT="algoritmos3D">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META NAME="Generator" CONTENT="LaTeX2HTML v2008">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="algoritmos3D.css">

<LINK REL="previous" HREF="node25.html">
<LINK REL="up" HREF="node24.html">
<LINK REL="next" HREF="node27.html">
<!--google-->
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-22456715-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>
</HEAD>

<BODY >

<DIV CLASS="navigation">
<A NAME="tex2html836"
  HREF="node25.html">
<IMG  ALIGN="BOTTOM" BORDER="0" ALT="previous"
 SRC="./icons//prev.png"></A> 
<A NAME="tex2html840"
  HREF="node24.html">
<IMG  ALIGN="BOTTOM" BORDER="0" ALT="up"
 SRC="./icons//up.png"></A> 
<A NAME="tex2html842"
  HREF="node27.html">
<IMG  ALIGN="BOTTOM" BORDER="0" ALT="next"
 SRC="./icons//next.png"></A> <div><fieldset>Siguiente: <b><A NAME="tex2html843"
  HREF="node27.html">Estructura secundaria</A></b>  Arriba: <b><A NAME="tex2html841"
  HREF="node24.html">Estructura primaria o secuencia</A></b>  Anterior: <b><A NAME="tex2html837"
  HREF="node25.html">Estabilidad y deformaci&#243;n de un</A></b></fieldset></div></DIV>
<!--End of Navigation Panel-->

<H1><A NAME="SECTION00320000000000000000"></A> <A NAME="dna2"></A>
<BR>
Dise&#241;o de primers para PCR
</H1>

<P>
La reacci&#243;n en cadena de la polimerasa 
(<A NAME="tex2html155"
  HREF="http://es.wikipedia.org/wiki/Reacci%C3%B3n_en_cadena_de_la_polimerasa">PCR</A>)
es una metodolog&#237;a est&#225;ndar en cualquier laboratorio de biolog&#237;a molecular y consta fundamentalmente
de 3 fases que se repiten un n&#250;mero de ciclos:

<P>

<DIV ALIGN="CENTER"><A NAME="fig:PCR"></A><A NAME="1888"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figura 3.5:</STRONG>
Diagrama de flujo de una reacci&#243;n de PCR, tomado de <A
 HREF="node46.html#Konietzny2003">Konietzny &amp; Greiner (2003)</A>.</CAPTION>
<TR><TD>
<DIV ALIGN="CENTER">
<IMG
  WIDTH="464" HEIGHT="575" ALIGN="BOTTOM" BORDER="0"
 SRC="./PCR.gif"
 ALT="Image PCR">

</DIV></TD></TR>
</TABLE>
</DIV>

<P>
Para cada aplicaci&#243;n de la PCR es necesario ajustar las condiciones y el dise&#241;o de la reacci&#243;n,
por ejemplo:

<UL>
<LI>la duraci&#243;n de las fases de hibridaci&#243;n y elongaci&#243;n
</LI>
<LI>el tipo de cebadores o  <i> primer  </i> empleados y sus temperaturas de alineamiento o  <i> annealing  </i> (<A HREF="node14.html#desnat">2.1</A>)
</LI>
<LI>el tipo de polimerasa utilizada
</LI>
<LI>las cantidad de los reactivos y de ADN molde
</LI>
<LI>la longitud del amplic&#243;n o producto obtenido
</LI>
</UL>

<P>
En esta secci&#243;n veremos algunos de los algoritmos habituales para el dise&#241;o de cebadores, 
que deben cumplir al menos tres condiciones: 

<P>

 <A NAME="reqprimers"></A><UL>
<LI>Una pareja de cebadores debe tener temperaturas de alineamiento muy cercanas para maximizar el rendimiento, 
lo cual suele traducirse en un contenido en GC similar, entre 50% y 60%. 
</LI>
<LI>Los primers no deben favorecer horquillas ( <i> hairpins  </i>) ni ser complementarios:
<PRE>
          5'GGGAAA                    5' GGGAAAATTCCAGGATCTAT 3'
             |||| )                       ||||  ||||
 3' TATCTAGGACCTTA            3' TATCTAGGACCTTAAAAGGG 5'
</PRE>
</LI>
<LI>Tras analizar una gran colecci&#243;n de primers publicados en la literatura, parece que conviene evitar secuencias 
que terminen en GGG,GGT,ATT,CGA,TAA o TTA (<A
 HREF="node46.html#Onodera2007">Onodera, 2007</A>).
</LI>
</UL>

<P>
Hay muchos programas que pueden ayudar en el dise&#241;o de primers en la web, como por ejemplo:

<UL>
<LI><A NAME="tex2html156"
  HREF="http://bioinfo.ut.ee/primer3/">primer3</A>
</LI>
<LI><A NAME="tex2html157"
  HREF="http://en.wikipedia.org/wiki/Vector_NTI">Vector NTI</A>
</LI>
<LI><SPAN  CLASS="textit">in silico</SPAN> PCR en <A NAME="tex2html158"
  HREF="http://insilico.ehu.es/PCR/">procariotas</A>
y en <A NAME="tex2html159"
  HREF="http://genome.ucsc.edu/cgi-bin/hgPcr">animales</A>
</LI>
</UL>

<P>
o estos otros para dise&#241;ar primers degenerados,

<UL>
<LI><A NAME="tex2html160"
  HREF="http://blocks.fhcrc.org/codehop.html">CODEHOP</A>
(sin mantenimiento)</LI>
<LI><A NAME="tex2html161"
  HREF="http://amplicon.sourceforge.net/">amplicon</A>
</LI>
<LI><A NAME="tex2html162"
  HREF="http://maya.ccg.unam.mx/primers4clades/">primers4clades</A>
(espec&#237;fico para aplicaciones filogen&#233;ticas)
</LI>
</UL>

<P>
Sin embargo, m&#225;s all&#225; del software elegido, es importante saber c&#243;mo se calculan ciertas propiedades moleculares de los primers,
para poder analizar con criterio los resultados obtenidos. 

<P>
Por ejemplo, si retomamos el modelo Nearest Neighbor (NN) de la secci&#243;n <A HREF="node25.html#dna1">3.1</A>, podemos calcular la <SPAN CLASS="MATH"><IMG
 WIDTH="21" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img15.png"
 ALT="$ T_{m}$"></SPAN>, 
que es la temperatura a la que la mitad de los primers se han hibridado con el ADN molde, pero tambi&#233;n 
la cantidad de ADN hibridado a cualquier temperatura, por ejemplo a la temperatura de alineamiento, la m&#225;s cr&#237;tica, 
que a menudo se aproxima como <SPAN CLASS="MATH"><IMG
 WIDTH="47" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img38.png"
 ALT="$ T_{m} - 5$"></SPAN>.

<P>
La siguiente ecuaci&#243;n relaciona exactamente la temperatura con la proporci&#243;n de ADN hibridado,
donde <SPAN CLASS="MATH"><IMG
 WIDTH="23" HEIGHT="33" ALIGN="MIDDLE" BORDER="0"
 SRC="img39.png"
 ALT="$ [A]$"></SPAN> es la concentraci&#243;n de hebras en exceso (los primers), <SPAN CLASS="MATH"><IMG
 WIDTH="23" HEIGHT="33" ALIGN="MIDDLE" BORDER="0"
 SRC="img40.png"
 ALT="$ [B]$"></SPAN> el ADN molde que queremos amplificar y <SPAN CLASS="MATH"><IMG
 WIDTH="13" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img41.png"
 ALT="$ R$"></SPAN> la 
<A NAME="tex2html163"
  HREF="http://en.wikipedia.org/wiki/Boltzmann_constant">constante de Boltzmann</A>
(R=1.987 cal/mol/k):
<P></P>
<DIV ALIGN="CENTER" CLASS="mathdisplay"><!-- MATH
 \begin{equation}
T_{m} = \frac{1000 \Delta H}{\Delta S + Rln([A]-\frac{[B]}{2})} - 273.15
\end{equation}
 -->
<TABLE CLASS="equation" CELLPADDING="0" WIDTH="100%" ALIGN="CENTER">
<TR VALIGN="MIDDLE">
<TD NOWRAP ALIGN="CENTER"><SPAN CLASS="MATH"><IMG
 WIDTH="238" HEIGHT="53" ALIGN="MIDDLE" BORDER="0"
 SRC="img42.png"
 ALT="$\displaystyle T_{m} = \frac{1000 \Delta H}{\Delta S + Rln([A]-\frac{[B]}{2})} - 273.15$"></SPAN></TD>
<TD NOWRAP CLASS="eqno" WIDTH="10" ALIGN="RIGHT">
(<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">4</SPAN>)</TD></TR>
</TABLE></DIV>
<BR CLEAR="ALL"><P></P>

<P>

<DIV ALIGN="CENTER"><A NAME="fig:TvsC"></A><A NAME="1890"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figura 3.6:</STRONG>
Curva te&#243;rica que muestra la dependencia entre temperatura y [ADN hibridado], tomada de (<A
 HREF="node46.html#Santalucia2007">SantaLucia, 2007</A>).</CAPTION>
<TR><TD>
<DIV ALIGN="CENTER">
<IMG
  WIDTH="615" HEIGHT="362" ALIGN="BOTTOM" BORDER="0"
 SRC="./TvsC.jpg"
 ALT="Image TvsC">

</DIV></TD></TR>
</TABLE>
</DIV>

<P>
Esta ecuaci&#243;n es m&#225;s fina y precisa que la regla de Wallace, que se basa solamente en la secuencia (<A
 HREF="node46.html#Santalucia2007">SantaLucia, 2007</A>):
<P></P>
<DIV ALIGN="CENTER" CLASS="mathdisplay"><!-- MATH
 \begin{equation}
T_{m} \sim 4GC + 2AT
\end{equation}
 -->
<TABLE CLASS="equation" CELLPADDING="0" WIDTH="100%" ALIGN="CENTER">
<TR VALIGN="MIDDLE">
<TD NOWRAP ALIGN="CENTER"><SPAN CLASS="MATH"><IMG
 WIDTH="120" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img43.png"
 ALT="$\displaystyle T_{m} \sim 4GC + 2AT$"></SPAN></TD>
<TD NOWRAP CLASS="eqno" WIDTH="10" ALIGN="RIGHT">
(<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN>)</TD></TR>
</TABLE></DIV>
<BR CLEAR="ALL"><P></P>

<P>
El ejercicio de esta secci&#243;n incluye:

<UL>
<LI>usar cualquier software que conozcas (o de los citados arriba) para dise&#241;ar varios primers
</LI>
<LI>con ayuda del siguiente c&#243;digo Python evaluar parejas de primers teniendo en cuenta su <SPAN CLASS="MATH"><IMG
 WIDTH="21" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img15.png"
 ALT="$ T_{m}$"></SPAN> 
de fusi&#243;n y su potencial de formaci&#243;n de horquillas
</LI>
<LI>compara las <SPAN CLASS="MATH"><IMG
 WIDTH="21" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img15.png"
 ALT="$ T_{m}$"></SPAN> obtenidas con las que resultan de aplicar la regla de Wallace
</LI>
<LI>prueba a modificar el c&#243;digo para calcular temperaturas de alineamiento donde la proporci&#243;n
de primer hibridado sea por ejemplo del 95%
<BR>
<PRE  CLASS="verbatim">#!/usr/bin/env python
# prog1.2

# adapted from Amplicon (Simon Neil Jarman, http://sourceforge.net/projects/amplicon/)

import math,string,getopt,sys

######################################################################################

#Calculation of Tm with nearest-neighbor bas stacking parameters#
def CalcTm(seq):
	
    cat=0.05
    NearPairsPlus = ['AA','AC','AG','AT','CA','CC','CG','CT',
                     'GA','GC','GG','GT','TA','TC','TG','TT']
    DeltaH =        [7.9,8.4,7.8,7.2,8.5,8.0,10.6,7.8,
                     8.2,9.8,8.0,8.4,7.2,8.2,8.5,7.9]
    DeltaS =        [22.2,22.4,21.0,20.4,22.7,19.9,27.2,21.0,
                     22.2,24.4,19.9,22.4,21.3,22.2,22.7,22,2]
    dH = 0
    dS = 0
    seq = seq+ ' '
    a = 0
    while a &lt; len(seq):
        b = 0
        while b &lt; len(NearPairsPlus):
            if seq[a-2:a] == NearPairsPlus[b]:
                dH = dH + DeltaH[b]
                dS = dS + DeltaS[b]
            b = b + 1
        a = a + 1
    a = a -1
    if seq[0]=='A' or seq[0]=='T' or seq[a] == 'A' or seq[a] == 'T':
        dH = dH + 2.3
        dS = dS + 4.1
    if seq[0]=='C'or seq[0]=='G' or seq[a]=='C'or seq[a]=='G':
        dH = dH + 0.1
        dS = dS - 2.8
	
    Tm = -dH * 1000 /(10.8-dS+(1.987*(math.log(0.00025)))) - 273.15 + (12*math.log(cat))
    return Tm

######################################################################################

#A nice function that returns a list of the component sequences from a string for a degenerate sequence#
def regenerate(oligo):
    inp =   'ACGTRYSWKMBDVHN'
    deg = ['A','C','G','T','AG','CT','CG','AT','GT','AC','CGT','AGT','ACG','ACT','ACGT']
    grow = ['']
    newgrow = ['']
    for a in range(0,len(oligo),1):
        for b in range(0,15,1):
            if oligo[a] == inp[b]:
                if b &gt; 3:
                    x = 0
                    newgrow = grow
                    while x &lt; len(deg[b])-1:
                        newgrow = newgrow + grow
                        x = x + 1
                grow = newgrow
                n = 0
                x=0
                for c in range(0,len(grow),1):
                    grow[c] = grow[c]+deg[b][x]
                    n = n + 1
                    if n == len(grow)/len(deg[b]):
                        n = 0
                        x=x+1
    return grow

#######################################################################################

#Assesses primers for hairpin loop formation#
def checkhairpins(primerseqs,minhplen,maxhplen,hpthresh):

    num = str(len(primerseqs))
    max=len(primerseqs[0])*(int(maxhplen)/100.0)
    numhp=0
    maxHpotential=0
    n=1
    
    for seq in primerseqs:
	#print 'oligo number '+str(n)+': '+seq+'\n'
	n=n+1
	high=perfectmatch(seq)
	thresh=(hpthresh/200.0)*high
	l=minhplen
	topcheck=0
	while l&lt;max:
	    tops,mids,bots,matches=hairpin(seq,l,thresh)
	    tops=tops[:5]
	    mids=mids[:5]
	    bots=bots[:5]
	    matches=matches[:5]
	    a=0
	    while a &lt; len(tops)-1:
		print tops[a]
		print mids[a]
		print bots[a]+'\n'
		print str(matches[a])+' / '+str(high/2-l)+ ' Potential H-Bonds\n'
		if matches[a]/float(high/2-l) &gt; maxHpotential:
		   maxHpotential = matches[a]/float(high/2-l) 
		if tops[a]&lt;&gt;[]:
		   topcheck=1
		a=a+1
	    l=l+1
	    
    return maxHpotential

#####################################################################################

#A function that scores strong and weak Watson-Crick base pairs as 3 and 2 in perfectly-matched d.s. DNA#
def perfectmatch(inseq):
    score=0
    for a in inseq:
        if a == 'A' or a =='T':
            score=score+2
        if a=='G'or a=='C':
            score=score+3
    return score

#####################################################################################

def hairpin(inseq,loopl,threshold):
    l=len(inseq)
    a=0
    max=1
    tops=[]
    bots=[]
    mids=[]
    matches=[]
    b=l
    while b &gt;1:
        match=0
        mid=''
        top = "5' "+ inseq[:b-1]
        loop=inseq[b-1:b+loopl-1]
        bot=inseq[b+loopl-1:l+1]
        q=len(top)-len(bot)
        if q&lt;0:
            q=q*-1        
        f=' '
        for a in range(1,q,1):
            f=f+' '
        top=top+'-'+loop
        revbot=''
        for a in range(len(bot)-1,-1,-1):
            revbot=revbot+bot[a]
        if len(top)-len(loop)-1&gt;len(bot):
            bot=f+revbot
        if len(top)-len(loop)-1&lt;len(bot):
            top=f+top
        for a in range(0,loopl,1):
            bot=bot+'-'
        bot=bot+'+'
        a=0
        while a &lt;len(bot)-loopl:
            inmatch=match
            if top[a]=='C' and bot[a]=='G' or top[a]=='G' and bot[a]=='C':
                match = match + 3
                mid=mid+':'
            if top[a]=='A' and bot[a]=='T' or top[a]=='T' and bot[a]=='A':
                match = match + 2
                mid=mid+'.'
            if top[a]=='T' and bot[a]=='G' or top[a]=='G' and bot[a]=='T':
                match = match + 2
                mid=mid+'~'
            if inmatch==match:
                mid=mid+' '
            a=a+1
        for a in range(0,loopl-1,1):
            mid=mid+' '
        mid=mid+'|'
        if match&gt;threshold:
            tops=tops+[top]
            bots=bots+[bot]
            mids=mids+[mid]
            matches=matches+[match]
            if int(match)&gt;max:
                max=int(match)
        top=''
        bot=''
        b=b-1
    newtops=[]
    newbots=[]
    newmids=[]
    newmatches=[]
    while max&gt;0:
        for a in range(0,len(matches)-1,1):
            if max==int(matches[a]):
                newtops=newtops+[tops[a]]
                newbots=newbots+[bots[a]]
                newmids=newmids+[mids[a]]
                newmatches=newmatches+[matches[a]]
        max=max-1        
    return newtops,newmids,newbots,newmatches

########################################################################

#Assesses primer sequences for self complementarity#
def selfcomp(primerseqs,propcomp,numcomp):
   
   perfect=perfectmatch(primerseqs[0])
   threshold=propcomp*perfect*0.01
   maxHpotential = 0
   
   n=1
   for a in primerseqs:
       comps=complementarity(a,'',threshold)
       comps=comps[:(numcomp*4)]
       #if comps==[]:
	#   print "\nNo self complementarity above threshold"
       n=n+1
       b=0
       while b&lt;len(comps):
	   print comps[b]
	   print comps[b+1]
	   print comps[b+2]
	   per = perfectmatch(comps[b])
	   print '\n ',comps[b+3]+' / '+str(per)+' Potential H-bonds\n'
	   if float(comps[b+3])/per &gt; maxHpotential:
              maxHpotential = float(comps[b+3])/per
	   b=b+4
   if len(primerseqs)&gt;1:
       #print "primer multiple sequence complementarities\n"
       n=1
       dmin=1
       for a in primerseqs:
	   d=dmin
	   while d &lt; len(primerseqs):
	       comps=complementarity(a,primerseqs[d],threshold)
	       comps=comps[:(numcomp*4)]
	       #print 'oligo combination '+str(n)+': '+a+' + '+primerseqs[d]
	       #if comps==[]:
		#   print "\n\nNo self complementarity above current threshold\n"
	       n=n+1
	       b=0
	       while b&lt;len(comps):
		   print comps[b]
		   print comps[b+1] 
		   print comps[b+2]
		   per = perfectmatch(comps[b])
		   print '\n '+comps[b+3]+' / '+str(per)+' Potential H-bonds\n'
		   if float(comps[b+3])/per &gt; maxHpotential:
		      maxHpotential = float(comps[b+3])/per
		   b=b+4
	       d=d+1
	   dmin=dmin+1
   return maxHpotential
	
############################################################################	

#A function for identifying complementarity between two sequences and returning lists of complementary pairs above a given threshold#
def complementarity(inseq,inseq2,threshold):
  
    matches = []
    max=1
    threshold=int(threshold)
    oligo="5' "+ inseq+" 3'"
    oligorev="3' "+reverse(inseq2)+" 5'"
    if inseq2=='':
        oligorev = ''
        a = len(oligo)-4
        while a &gt; 1:
            oligorev = oligorev + oligo[a]
            a = a - 1
        oligorev="3' "+oligorev+" 5'"
    if len(oligo)&gt;len(oligorev):
        d=len(oligo)-len(oligorev)
        while d&gt;0:
            oligorev=oligorev+' '
            d=d-1
    if len(oligo)&lt;len(oligorev):
        d=len(oligorev)-len(oligo)
        while d&gt;0:
            oligo=' '+oligo
            d=d-1
    Toligo = oligo
    mid=u''
    for a in range(len(Toligo),0,-1):
        match = 0
        mid=''
        for b in range(0,len(oligorev)-3,1):
            inmatch=match
            if Toligo[b]=='C' and oligorev[b] =='G' or Toligo[b]=='G' and oligorev[b] =='C':
                match = match + 3
                mid=mid+':'
            if Toligo[b]=='A' and oligorev[b] =='T' or Toligo[b]=='T' and oligorev[b] =='A':
                match = match + 2
                mid=mid+'.'
            if Toligo[b]=='G' and oligorev[b] =='T' or Toligo[b]=='T' and oligorev[b] =='G':
                match = match + 2
                mid=mid+'~'
            if inmatch==match:
                mid=mid+' '
        if match &gt; threshold:
            smatch = str(match)
            matches = matches+[Toligo]+[mid]+[oligorev]+[smatch]
            if int(match)&gt;max:
                max=int(match)
        Toligo = ' '+ Toligo 
    Toligorev = oligorev
    for a in range(len(oligo),0,-1):
        match = 0
        mid=u''
        for b in range(0,len(oligorev)-3,1):
            inmatch=match
            if oligo[b]=='C' and Toligorev[b] =='G' or oligo[b]=='G' and Toligorev[b] =='C':
                match = match + 3
                mid=mid+':'
            if oligo[b]=='A' and Toligorev[b] =='T' or oligo[b]=='T' and Toligorev[b] =='A':
                match = match + 2
                mid=mid+'.'
            if oligo[b]=='G' and Toligorev[b] =='T' or oligo[b]=='T' and Toligorev[b] =='G':
                match = match + 2
                mid=mid+'~'
            if inmatch==match:
                mid=mid+' '
        if match &gt; threshold:
            f=0
            for e in matches:
                if e == mid:
                    f=1
            if f &lt;&gt;1:
                smatch = str(match)
                matches = matches+[oligo]+[mid]+[Toligorev]+[smatch]
                if int(match) &gt; max:
                    max=match
            Toligorev = ' '+ Toligorev 
    newmatches=[]
    while max&gt;0:
        for a in range(3,len(matches)-1,4):
            if max==int(matches[a]):
                one=matches[a-3]
                two=matches[a-2]
                thr=matches[a-1]
                fou=matches[a]
                fou=str(fou)
                newmatches=newmatches+[one]+[two]+[thr]+[fou]
        max=max-1
    return newmatches

################################################################################
    
#A function that returns the reverse of a given sequence#
def reverse(inseq):
    reversed=''
    l=len(inseq)-1
    for a in range(l,-1,-1):
        reversed=reversed+inseq[a]
    return reversed
    
#################################################################################    

#Checks forward and reverse primers for complementarity with each other#
def crosscomp(fprimer,rprimer,propcomp,numcomp):
    
    growF=regenerate(fprimer)
    growR=regenerate(rprimer)
    perfect1=perfectmatch(fprimer)
    perfect2=perfectmatch(rprimer)
    if perfect2&lt;perfect1:
	perfect1=perfect2
    threshold=propcomp*perfect1*0.01
    
    crossHpotential = 0
    n=1
    q=0
    while q &lt;len(growR):
	for a in growF:
	    comps=complementarity(a,growR[q],threshold)
	    comps=comps[:(numcomp*4)]
	    #print 'oligo '+str(n)+' f: '+a+' r: '+growR[q]
	    #if comps==[]:
		#print "\n\nNo complementarity above current threshold\n"
	    n=n+1
	    b=0
	    while b&lt;len(comps):
		print comps[b]
		print comps[b+1]
		print comps[b+2]
		per=perfectmatch(comps[b])
		print '\n '+comps[b+3]+' / '+str(per)+' Potential H-bonds'
		if float(comps[b+3])/per &gt; crossHpotential:
		   crossHpotential = float(comps[b+3])/per
		b=b+4
	q=q+1
    
    return crossHpotential

#################################################################################

#Function that returns degree of degeneracy of a given sequence#
def degeneracy(inseq):
    score=1
    for a in inseq:
        if a=='R' or a=='Y' or a=='S' or a=='W' or a=='M' or a=='K':
            score=score*2
        if a=='V' or a=='H' or a=='D' or a=='B':
            score=score*3
        if a=='N':
            score=score*4
    return score

#################################################################################

def main(argv):

    maxdegen = 128

    if len(sys.argv) &lt; 3:
        print "usage: python check_primers.py 5'forward_primer3' 5'reverse primer3'"
	sys.exit(-1)
	
    fprimer = string.upper(sys.argv[1])
    rprimer = string.upper(sys.argv[2])
    
    flowtm = rlowtm = 100
    fhightm = rhightm = 0
    fhpinHpotential = fselfHpotentail = 0
    rhpinHpotential = rselfHpotentail = 0
    crossHpotential = 0
    fdegen = rdegen = 0
    
    ## 1) take care of forward primer		    
    print "# forward primer "+fprimer+'\n'	                   

    fdegen = degeneracy(fprimer)
    
    print "# fdegen= %g\n" % fdegen
    
    if fdegen &lt;= maxdegen :
 
       fprimerseqs = regenerate(fprimer)

       # 1.0) print each regenerated foligo
       for s in fprimerseqs:
         print "# fundegseq ", s
       print "\n"
        
       # 1.1) calculate tms
       for s in fprimerseqs:
          tm= CalcTm(s)
          if tm&lt;flowtm:
             flowtm=tm
          if tm&gt;fhightm:
             fhightm=tm

       # 1.2) calculate hairpins
       fhpinHpotential = checkhairpins(fprimerseqs,2,40,35)
    
       # 1.3) calculate self-complementarities
       fselfHpotentail = selfcomp(fprimerseqs,40,4)
    
       # 1.4) report results
       print "# flowTm= %1.1f\n# fhighTm= %1.1f" % (flowtm,fhightm) 
       print "# fhairpin potential= %1.2f\n# fselfcompl potential= %1.2f\n" % (fhpinHpotential,fselfHpotentail)
    
    else :
       print "primer skipped, too degenerated (&gt; ",maxdegen,")\n"    

    ## 2) now do reverse primer
    print "# reverse primer "+rprimer+'\n'	    

    rdegen = degeneracy(rprimer)

    print "# rdegen= %g\n" % rdegen

    if rdegen &lt;= maxdegen :

       rprimerseqs = regenerate(rprimer)
       
       # 2.0) print each regenerated roligo
       for s in rprimerseqs:
         print "# rundegseq ", s
       print "\n"

       # 2.1) calculate tms
       for s in rprimerseqs:
          tm= CalcTm(s)
          if tm&lt;rlowtm:
             rlowtm=tm
          if tm&gt;rhightm:
             rhightm=tm
            
       # 2.2) calculate hairpins
       rhpinHpotential = checkhairpins(rprimerseqs,2,40,35)
    
       # 2.3) calculate self-complementarities
       rselfHpotentail = selfcomp(rprimerseqs,40,4)
    
       # 2.4) report results
       print "# rlowTm= %1.1f\n# rhighTm= %1.1f" % (rlowtm,rhightm) 
       print "# rhairpin potential= %1.2f\n# rselfcompl potential= %1.2f\n" % (rhpinHpotential,rselfHpotentail)
    
    else :
       print "primer skipped, too degenerated (&gt; ",maxdegen,")\n"    

    ## 3) finally chech cross-complementarities
    if fdegen &lt;= maxdegen and rdegen &lt;= maxdegen :
       crossHpotential = crosscomp(fprimer,rprimer,40,4)
       print "\n# cross-compl potential= %1.1f" % crossHpotential


########################### MAIN ################################################

main(sys.argv)
</PRE>
</LI>
</UL>

<P>

<DIV CLASS="navigation"><hr> 
<A NAME="tex2html836"
  HREF="node25.html">
<IMG  ALIGN="BOTTOM" BORDER="0" ALT="previous"
 SRC="./icons//prev.png"></A> 
<A NAME="tex2html840"
  HREF="node24.html">
<IMG  ALIGN="BOTTOM" BORDER="0" ALT="up"
 SRC="./icons//up.png"></A> 
<A NAME="tex2html842"
  HREF="node27.html">
<IMG  ALIGN="BOTTOM" BORDER="0" ALT="next"
 SRC="./icons//next.png"></A> </DIV>
<!--End of Navigation Panel-->
<ADDRESS>
<a href="http://hdl.handle.net/10261/21892">PDF</a><br>Bruno Contreras-Moreira<br><a href="http://www.eead.csic.es/compbio">http://www.eead.csic.es/compbio</a>
</ADDRESS>
</BODY>
</HTML>
