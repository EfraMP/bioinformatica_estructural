<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<!--Converted with LaTeX2HTML 2018.2 (Released May 16, 2018) -->
<HTML>
<HEAD>
<TITLE>Protein fold recognition </TITLE>
<META NAME="description" CONTENT="Protein fold recognition ">
<META NAME="keywords" CONTENT="algoritmos3D">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META NAME="Generator" CONTENT="LaTeX2HTML v2018.2">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="algoritmos3D.css">

<LINK REL="next" HREF="node35.html">
<LINK REL="previous" HREF="node33.html">
<LINK REL="up" HREF="node32.html">
<LINK REL="next" HREF="node35.html">
<!--google-->
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-22456715-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>
</HEAD>

<BODY >

<DIV CLASS="navigation">
<A NAME="tex2html1053"
  HREF="node33.html">
<IMG  ALIGN="BOTTOM" BORDER="0" ALT="previous"
 SRC="./icons//prev.png"></A> 
<A NAME="tex2html1059"
  HREF="node32.html">
<IMG  ALIGN="BOTTOM" BORDER="0" ALT="up"
 SRC="./icons//up.png"></A> 
<A NAME="tex2html1061"
  HREF="node35.html">
<IMG  ALIGN="BOTTOM" BORDER="0" ALT="next"
 SRC="./icons//next.png"></A> <div><fieldset>Siguiente: <b><A NAME="tex2html1062"
  HREF="node35.html">Modelado de prote&#237;nas por homolog&#237;a</A></b>  Arriba: <b><A NAME="tex2html1060"
  HREF="node32.html">Estructura terciaria</A></b>  Anterior: <b><A NAME="tex2html1054"
  HREF="node33.html">Comparaci&#243;n de estructura terciaria entre</A></b></fieldset></div></DIV>
<!--End of Navigation Panel-->

<H1><A NAME="SECTION00520000000000000000"></A> <A NAME="FRsection"></A>
<BR>
 <i> Protein fold recognition  </i>
</H1>

<P>
Al analizar secuencias gen&#243;micas frecuentemente encontraremos marcos de lectura (te&#243;ricos) que codifican para prote&#237;nas que aparentemente no se parecen a ninguna otra (llamadas a veces  <i> orphans  </i> en la literatura), 
o que s&#243;lo tienen similitudes obvias con prote&#237;nas de funci&#243;n desconocida. Esto puede deberse a que de veras son 
mol&#233;culas observadas por primera vez, o como vimos en <A HREF="node12.html#3dcons">1.3.5</A>, a que la evoluci&#243;n ha conservado en mayor grado
la estructura y topolog&#237;a de las prote&#237;nas hom&#243;logas que sus secuencias. 

<P>
La segunda posibilidad ha justificado una familia de m&#233;todos llamados gen&#233;ricamente de  <i> Fold Recognition  </i> (FR), 
que tienen como objeto reconocer a qu&#233; tipo de plegamiento (de los conocidos) se debe asignar una secuencia problema, 
especialmente cuando b&#250;squedas m&#225;s convencionales con 
<A NAME="tex2html268"
  HREF="http://blast.ncbi.nlm.nih.gov/Blast.cgi">BLAST</A>
o 
<A NAME="tex2html269"
  HREF="http://www.ebi.ac.uk/Tools/fasta/index.html">FASTA</A>
han fracasado.
Hist&#243;ricamente algunos de estos m&#233;todos se han llamado de
<A NAME="tex2html270"
  HREF="http://en.wikipedia.org/wiki/Threading_%28protein_sequence%29"> <i> threading  </i></A>, 
ya que ciertos algoritmos 
literalmente enhebran la secuencia problema en patrones de coordenadas conocidas, normalmente un subconjunto no redundante
del PDB, para ver si es compatible con alguno, como en la siguiente figura:

<P>

<DIV ALIGN="CENTER"><A NAME="fig:threading"></A><A NAME="3353"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figura 5.4:</STRONG>

Diagrama de flujo de los algoritmos de reconocimiento de plegamiento (FR).
Figura tomada de <A
 HREF="node50.html#Guo2008">Guo &amp; Xu (2008)</A>. Copyright (2008) Frontiers in Bioscience. 
</CAPTION>
<TR><TD>
<DIV ALIGN="CENTER">
<IMG
  WIDTH="596" HEIGHT="438" ALIGN="BOTTOM" BORDER="0"
 SRC="./threading.jpg"
 ALT="Image threading">

</DIV></TD></TR>
</TABLE>
</DIV>

<P>
El problema de FR lo podemos plantear as&#237;:

<UL>
<LI><SPAN  CLASS="textbf">PROBLEMA:</SPAN> conocemos la secuencia de una prote&#237;na, pero desconocemos su tipo de plegamiento y su funci&#243;n
</LI>
<LI><SPAN  CLASS="textbf">SOLUCI&#211;N PROPUESTA:</SPAN> comparar la secuencia con todos los plegamientos conocidos, calcular el grado de parecido/compatibilidad con cada uno de ellos y devolver una lista ordenada
</LI>
</UL>

<P>
Se han publicado muchos algoritmos diferentes de FR; en todos ellos de alguna manera se asigna una estructura T a una secuencia A:

<UL>
<LI>Por medio de b&#250;squedas PSI-BLAST bidireccionales transitivas (<A
 HREF="node50.html#Koretke2002">Koretke <EM>et&nbsp;al.</EM>, 2002</A>). 
La idea es que si buscamos secuencias hom&#243;logas a partir de A llegamos a encontrar, en alguna iteraci&#243;n, 
la secuencia T entre los resultados con cierta significancia estad&#237;stica. De la misma manera, a partir de la secuencia de T llegamos a la secuencia A.

<P>
</LI>
<LI>Representando cada plegamiento o  <i> fold  </i> por medio de las secuencias conocidas que se pliegan en esa conformaci&#243;n
y comparten estructura secundaria. Esto se puede hacer por medio de perfiles de secuencia (<A
 HREF="node50.html#Gribskov1987">Gribskov <EM>et&nbsp;al.</EM>, 1987</A>), 
que son matrices sustituci&#243;n de amino&#225;cidos espec&#237;ficas de posici&#243;n, 
o <A NAME="tex2html271"
  HREF="http://en.wikipedia.org/wiki/Hidden_Markov_model">modelos ocultos de Markov</A>, 
que modelan expl&#237;citamente con qu&#233; probabilidad se pueden emitir secuencias compatibles con ese plegamiento.

<P>
</LI>
<LI>Por medio de alineamientos secuencia-perfil o los m&#225;s sensibles perfil-perfil (<A
 HREF="node50.html#Soding2005">Soding, 2005</A>) que son la raz&#243;n del &#233;xito del servidor <A NAME="tex2html272"
  HREF="https://toolkit.tuebingen.mpg.de/#/tools/hhpred">HHpred</A>.

<P>
</LI>
<LI>Usando potenciales estad&#237;sticos para evaluar la cercan&#237;a de los residuos de una secuencia
dado un plegamiento (lo que llamamos  <i> threading  </i> (<A
 HREF="node50.html#Threader1992">Jones <EM>et&nbsp;al.</EM>, 1992</A>)). Estos m&#233;todos requieren precalcular,
sobre una colecci&#243;n de plegamientos no redundantes, con qu&#233; frecuencia y a qu&#233; distancia se forman 
parejas de residuos en las estructuras conocidas. 
<P>
</LI>
</UL>

<P>
Probablemente la mejor manera de evaluar objetivamente y elegir un m&#233;todo de FR 
son experimentos colectivos a ciegas con secuencias cuyas estructuras experimentales se hacen p&#250;blicas
tras las entrega de las predicciones. Hay dos tipos de experimentos de estipo: 
<A NAME="tex2html273"
  HREF="http://predictioncenter.org/index.cgi?page=public_serv">CASP</A>, 
que mide bianualmente la competencia de los algoritmos de los grupos participantes, y 
<A NAME="tex2html274"
  HREF="https://www.cameo3d.org">CAMEO</A>, que hace evaluaciones continuas no supervisadas.

<P>
En palabras de <A
 HREF="node50.html#Kelley2015">Kelley <EM>et&nbsp;al.</EM> (2015)</A>, desarrollador principal de 
<A NAME="tex2html275"
  HREF="http://www.sbg.bio.ic.ac.uk/phyre2">Phyre2</A>, uno de los m&#225;s completos,
los mejores predictores tienen resultados indistinguibles en la mayor parte de los casos,
pero en los casos mas complejos desde hace tiempo destaca por su consistencia y 
superiores resultados <A NAME="tex2html276"
  HREF="http://zhanglab.ccmb.med.umich.edu/I-TASSER">I-TASSER</A>.

<P>
Estas herramientas web son adecuadas para estudiar unas pocas secuencias, pero si queremos hacer un experimento de FR 
a gran escala, entonces buena idea instalar localmente el software elegido, como por ejemplo
<A NAME="tex2html277"
  HREF="https://github.com/soedinglab/hh-suite">hh-suite</A>, el software que da vida a 
<A NAME="tex2html278"
  HREF="https://toolkit.tuebingen.mpg.de/#/tools/hhpred">HHpred</A>.

<P>
El siguiente programa es un prototipo de alineamiento perfil-perfil que usa adem&#225;s predicciones de estructura secundaria (ver figura <A HREF="node31.html#fig:psipred">4.4</A>) 
para guiar el alineamiento. Es un algoritmo de programaci&#243;n din&#225;mica, que puedes comprender mejor con ayuda 
del <A NAME="tex2html279"
  HREF="http://protein.bio.puc.cl/websoftware/web/?sid=3"> <i> Sequence Alignment Teacher  </i></A>
(<A
 HREF="node50.html#Ibarra2010">Ibarra &amp; Melo, 2010</A>).

<P>
Para probarlo necesitaras descargar los archivos de entrada
(<A NAME="tex2html280"
  HREF="./files/1ngk_A.pssm">1ngk_A.pssm</A>,<A NAME="tex2html281"
  HREF="./files/1s69_A.pssm">1s69_A.pssm</A>,
<A NAME="tex2html282"
  HREF="./files/1ngk_A.psipred">1ngk_A.psipred</A>,<A NAME="tex2html283"
  HREF="./files/1s69_A.psipred">1s69_A.psipred</A>):
<BR>
<PRE  CLASS="verbatim">#!/usr/bin/perl -w

# programa 3.2 algoritmo de alineamiento global perfil-perfil
# Bruno Contreras-Moreira

use strict;

my %AAORDER = ('A',1,'R',2,'N',3,'D',4,'C',5,'Q',6,'E',7,'G',8,'H',9,'I',10,'L',11,
		'K',12,'M',13,'F',14,'P',15,'S',16,'T',17,'W',18,'Y',19,'V',20);
my $GAPCOST = -8; # coste de un gap 
my $SSBONUS = 2;  # premio por igual estructura secundaria

## -1) archivos de entrada
my $perfil1 = './files/1ngk_A.pssm'; # perfil generado con PSI-BLAST
my $perfil2 = './files/1s69_A.pssm'; 
my $SS1     = './files/1ngk_A.psipred'; # estructura secundaria predicha con PSIPRED
my $SS2     = './files/1s69_A.psipred'; 

print "# $0 input: $perfil1 $perfil2 $SS1 $SS2 params: $GAPCOST $SSBONUS\n\n";

## 0) define variables y lee perfiles 
my ($ID,$total,$gaps,@matrix,$l1,$l2,$i,$j,$aa1,$aa2,$par) = (0,0,0);
my ($align1,$align2,$ss1,$ss2,$ruler,$gapi,$gapj,$score) = ('','','','','');

my ($seq1,@perfil1) = lee_perfil($perfil1);
my ($seq2,@perfil2) = lee_perfil($perfil2);
my @SS1 = lee_SS($SS1);
my @SS2 = lee_SS($SS2);

$l1 = length($seq1);
$l2 = length($seq2); 

## 1) define e inicia matriz de programacion dinamica
# http://es.wikipedia.org/wiki/Algoritmo_Needleman-Wunsch
for($j=0;$j&lt;=$l1;$j++){ $matrix[0][$j]{'score'} = $j * $GAPCOST; }
for($i=0;$i&lt;=$l2;$i++){ $matrix[$i][0]{'score'} = $i * $GAPCOST; }

## 2) rellena la matriz fila a fila
for($i=1;$i&lt;=$l2;$i++) 
{
	for($j=1;$j&lt;=$l1;$j++) 
	{
        	$score = evalua_par($perfil1[$j-1],$perfil2[$i-1]);
		if($SS1[$j-1] eq $SS2[$i-1] &amp;&amp; $SS2[$i-1] ne 'C'){ $score += $SSBONUS }
		
		# calcula 3 posibles scores: diagonal y gaps
        	$par = $matrix[$i-1][$j-1]{'score'} + $score;
        	$gapi = $matrix[$i-1][$j]{'score'} + $GAPCOST;
        	$gapj = $matrix[$i][$j-1]{'score'} + $GAPCOST;
		
		($matrix[$i][$j]{'score'},$matrix[$i][$j]{'dir'}) = max($par,$gapi,$gapj);
	}
}

## 3) reconstruye alineamiento
($i,$j) = ($l2,$l1); 
$score = $matrix[$i][$j]{'score'};

while (1) 
{
    last if(!$matrix[$i][$j]{'dir'});
     
    if ($matrix[$i][$j]{'dir'} eq 'diagonal') 
    {
    	$i--; $j--;
	$aa1 = substr($seq1,$j,1);
	$aa2 = substr($seq2,$i,1);
        $align1 = $aa1 . $align1;
        $align2 = $aa2 . $align2;
	$ss1    = $SS1[$j] . $ss1;
	$ss2    = $SS2[$i] . $ss2;
	if($aa1 eq $aa2)
	{ 
		$ID++; 
		$ruler = '|' . $ruler;
	}
	else{ $ruler = ' ' . $ruler; }
	$total++;
    }
    elsif($matrix[$i][$j]{'dir'} eq 'gapj') 
    {
        $align1 = substr($seq1,$j-1,1) . $align1;
        $align2 = '-' . $align2;
	$ss1    = $SS1[$j-1] . $ss1;
	$ss2    = '-' . $ss2;
	$ruler = ' ' . $ruler;
        $j--;
    }
    else 
    {
        $align1 = '-' . $align1;
        $align2 = substr($seq2,$i-1,1) . $align2;
	$ss1    = '-' . $ss1;
	$ss2    = $SS2[$i-1] . $ss2;
	$ruler = ' ' . $ruler;
        $i--;
	$gaps++; # en secuencia1
    }   
}

print "# identical aligned residues = $ID/$total gaps = $gaps score = $score\n";
print "$perfil1\n$ss1\n$align1\n$ruler\n$align2\n$ss2\n$perfil2\n";

#####################################################

# lee fichero PSSM generado por PSI-BLAST con opcion -Q
sub lee_perfil
{
	my ($PSSMfile) = @_;
	 
	my ($secuencia,@perfil,$col,$aa,$weights) = ('');

        # 1 K   -4  2 -3 -3 -6  6  1 -5 -3 -6 -5  4 -4 -6  5 -3 -4 -6 -5 -5     
	open(PSSM,$PSSMfile) || die "# lee_perfil: no puedo leer $PSSMfile\n";
	while(&lt;PSSM&gt;)
	{
		if(/^\s+(\d+)\s+(\w)\s+(.+?)\n/)
		{
			($col,$aa,$weights)=($1,$2,$3); 
			$col -= 1; # cuenta desde 0
			push(@{$perfil[$col]},$aa); # posicion 0: secuencia
			push(@{$perfil[$col]},(split(/\s+/,$weights))); # pos 1..20: pesos
			$secuencia .= $aa;
		}
	}
	close(PSSM);

	return ($secuencia,@perfil);    
}
    
# evalua una pareja de aminoacidos consultando su vector de pesos/sustituciones
# usa global: %AAORDER
sub evalua_par
{
	my ($pssv1,$pssv2) = @_;
	
	my $score1 = $pssv2-&gt;[$AAORDER{$pssv1-&gt;[0]}];
	my $score2 = $pssv1-&gt;[$AAORDER{$pssv2-&gt;[0]}];
	return sprintf("%1.2f",($score1+$score2)/2);
}

# lee fichero de prediccion de estructura secundaria generado con PSIPRED
sub lee_SS
{
	my($SSfile) = @_;
	
	my (@SS);

	#Pred: CCHHHHHCCHHHHHHHHHHHHHHHHCCHHHHHHCCCCCHHHHHHHHHHHHHHHHCCCCCC
	open(PSIPRED,$SSfile) || die "# lee_SS: no puedo leer $SSfile\n";
	while(&lt;PSIPRED&gt;)
	{
		if(/^Pred: (\w+?)\n/){ push(@SS,(split(//,$1))); }
	}
	close(PSIPRED);

	return (@SS);    
}	

sub max
{
	my ($par,$gapi,$gapj) = @_;
	
	if($gapi&gt;$gapj &amp;&amp; $gapi&gt;$par){ return($gapi,'gapi'); }
	elsif($gapj &gt;= $par &amp;&amp; $gapj &gt;= $gapi){ return($gapj,'gapj'); }
	else{ return($par,'diagonal'); }
}            		
</PRE>
<DIV CLASS="navigation"><hr> 
<A NAME="tex2html1053"
  HREF="node33.html">
<IMG  ALIGN="BOTTOM" BORDER="0" ALT="previous"
 SRC="./icons//prev.png"></A> 
<A NAME="tex2html1059"
  HREF="node32.html">
<IMG  ALIGN="BOTTOM" BORDER="0" ALT="up"
 SRC="./icons//up.png"></A> 
<A NAME="tex2html1061"
  HREF="node35.html">
<IMG  ALIGN="BOTTOM" BORDER="0" ALT="next"
 SRC="./icons//next.png"></A> </DIV>
<!--End of Navigation Panel-->
<ADDRESS>
<a href="http://hdl.handle.net/10261/21892">PDF</a><br>Contreras-Moreira,B. (2018) Algoritmos en bioinform&aacute;tica estructural. <a href="https://doi.org/10.20350/digitalcsic/8544">doi:10.20350/digitalcsic/8544</a><br><a href="http://www.eead.csic.es/compbio">http://www.eead.csic.es/compbio</a>
</ADDRESS>
</BODY>
</HTML>
