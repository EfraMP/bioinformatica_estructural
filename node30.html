<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<!--Converted with LaTeX2HTML 2018.2 (Released May 16, 2018) -->
<HTML>
<HEAD>
<TITLE>Estructura secundaria de RNA</TITLE>
<META NAME="description" CONTENT="Estructura secundaria de RNA">
<META NAME="keywords" CONTENT="algoritmos3D">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META NAME="Generator" CONTENT="LaTeX2HTML v2018.2">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="algoritmos3D.css">

<LINK REL="next" HREF="node31.html">
<LINK REL="previous" HREF="node29.html">
<LINK REL="up" HREF="node29.html">
<LINK REL="next" HREF="node31.html">
<!--google-->
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-22456715-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>
</HEAD>

<BODY >

<DIV CLASS="navigation">
<A NAME="tex2html999"
  HREF="node29.html">
<IMG  ALIGN="BOTTOM" BORDER="0" ALT="previous"
 SRC="./icons//prev.png"></A> 
<A NAME="tex2html1005"
  HREF="node29.html">
<IMG  ALIGN="BOTTOM" BORDER="0" ALT="up"
 SRC="./icons//up.png"></A> 
<A NAME="tex2html1007"
  HREF="node31.html">
<IMG  ALIGN="BOTTOM" BORDER="0" ALT="next"
 SRC="./icons//next.png"></A> <div><fieldset>Siguiente: <b><A NAME="tex2html1008"
  HREF="node31.html">(Des)estructura secundaria de prote&#237;nas</A></b>  Arriba: <b><A NAME="tex2html1006"
  HREF="node29.html">Estructura secundaria</A></b>  Anterior: <b><A NAME="tex2html1000"
  HREF="node29.html">Estructura secundaria</A></b></fieldset></div></DIV>
<!--End of Navigation Panel-->

<H1><A NAME="SECTION00410000000000000000"></A> <A NAME="SSRNA"></A>
<BR>
Estructura secundaria de RNA
</H1>

<P>
En contraste con las mol&#233;culas de DNA, que en sus papeles m&#225;s comunes act&#250;an como dobles h&#233;lices,
las mol&#233;culas de RNA pueden adoptar una mayor variedad de conformaciones, igual de complejas que las de
las prote&#237;nas, que a su vez les permiten tener diferentes funciones , ya sea mensajero, RNA de transferencia,
ribosomal, regulador o enzima. Por primera vez en este curso vamos a ir un poco m&#225;s all&#225; de lo que expresa
una secuencia lineal:

<P>

<UL>
<LI><SPAN  CLASS="textbf">PROBLEMA:</SPAN> desconocemos la estructura de una mol&#233;cula de hebra sencilla de RNA pero conocemos su secuencia
</LI>
<LI><SPAN  CLASS="textbf">SOLUCI&#211;N PROPUESTA:</SPAN> predecir su estructura secundaria en base a las subsecuencias complementarias que contiene
</LI>
</UL>

<P>

<DIV ALIGN="CENTER"><A NAME="fig:RNAss"></A><A NAME="2648"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figura 4.1:</STRONG>

Estructura secundaria de un RNA (A) correspondiente a la estructura (B), tomada de <A
 HREF="node50.html#Noller2004">Noller (2004)</A> y reproducida con permiso.
</CAPTION>
<TR><TD>
<DIV ALIGN="CENTER">
<IMG
  WIDTH="593" HEIGHT="386" ALIGN="BOTTOM" BORDER="0"
 SRC="./RNAss.png"
 ALT="Image RNAss">

</DIV></TD></TR>
</TABLE>
</DIV>

<P>
La estructura secundaria de una mol&#233;cula de RNA, sostenida por medio de 
puentes de hidr&#243;geno (de tipo Watson-Crick y
<A NAME="tex2html206"
  HREF="http://en.wikipedia.org/wiki/Hoogsteen_base_pair">Hoogsteen</A>) entre nucle&#243;tidos,
puede aproximarse a partir del conocimiento de la secuencia, aunque obviamente se pierde parte de la complejidad
del plegamiento, como sugiere la figura <A HREF="#fig:RNAss">4.1</A>. Para qu&#233; sirven este tipo de predicciones? 
Por ejemplo, para descubrir RNAs no codificantes, que a menudo tienen funciones biol&#243;gicas importantes, 
como se discute en el art&#237;culo de <A
 HREF="node50.html#Washietl2005">Washietl <EM>et&nbsp;al.</EM> (2005)</A>.
Hay muchos programas disponibles que pueden ayudarnos en este tipo de tareas, como 
<A NAME="tex2html207"
  HREF="http://www.major.iric.ca/MC-Pipeline">MC-Fold | MC-Sym</A>,
<A NAME="tex2html208"
  HREF="http://mfold.rna.albany.edu/?q=mfold">Mfold</A>,
<A NAME="tex2html209"
  HREF="http://www.tbi.univie.ac.at/~ivo/RNA/">Vienna</A>,
<A NAME="tex2html210"
  HREF="http://www.tbi.univie.ac.at/~wash/RNAz/">RNAz</A>, 
<A NAME="tex2html211"
  HREF="http://infernal.janelia.org/">infernal</A>
o
<A NAME="tex2html212"
  HREF="http://www.bioinf.uni-freiburg.de/~costa/EDeN.tgz">EDeN</A>, especializado en ncRNAs.

<P>
Un programa complementario, que asigna elementos de estructura secundaria dadas unas coordenadas en formato PDB, es 
<A NAME="tex2html213"
  HREF="http://web.x3dna.org/dssr">DSSR</A>.

<P>
Aqu&#237; nos vamos a centrar en ilustrar el algoritmo de <A
 HREF="node50.html#Nussinov1978">Nussinov <EM>et&nbsp;al.</EM> (1978)</A> para predecir estructura secundaria de RNA 
por medio de alineamientos, que usa una estrategia de 
<A NAME="tex2html214"
  HREF="http://es.wikipedia.org/wiki/Programaci%C3%B3n_din%C3%A1mica_(inform%C3%A1tica)">programaci&#243;n din&#225;mica</A>
(DP)
para maximizar el n&#250;mero de puentes de hidr&#243;geno que se forman dentro de la secuencia. &#201;ste puede decirse que es
el algoritmo fundamental para resolver este problema aunque tiene algunas limitaciones. Por ejemplo, no considera la posibilidad de 
pseudonudos (<A NAME="tex2html215"
  HREF="http://en.wikipedia.org/wiki/Pseudoknot"> <i> pseudoknots  </i></A>) ni tiene en cuenta el 
apilamiento de bases ( <i> base stacking  </i>),
un tipo de interacci&#243;n que favorece la estabilidad de estas estructuras, elementos que s&#237; son proyectados en el
<A NAME="tex2html216"
  HREF="http://en.wikipedia.org/wiki/List_of_RNA_structure_prediction_software">software actual</A>
(<A
 HREF="node50.html#dotu_ivan_2014_1066354">Dotu <EM>et&nbsp;al.</EM>, 2014</A>).

<P>
El c&#243;digo fuente que se muestra implementa este algoritmo, 
evaluando recursivamente hasta 4 situaciones en cada posici&#243;n de la matrix DP (<A
 HREF="node50.html#Eddy2004b">Eddy, 2004</A>):

<UL>
<LI>caso1: nuevo par de bases alineado
</LI>
<LI>caso2: indel en un extremo, se conserva score anterior
</LI>
<LI>caso3: indel en extremo opuesto, se conserva score
</LI>
<LI>caso4: bifurcaci&#243;n en base <SPAN CLASS="MATH"><IMG
 WIDTH="14" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img34.png"
 ALT="$k$"></SPAN> si hay distancia suficiente 
</LI>
</UL>

<P>
<BR>
<PRE  CLASS="verbatim">#!/usr/bin/perl -w

# prog2.1 algoritmo tipo Nussinov de prediccion de estructura secundaria de RNA,
# adaptado de:
# F Burkowski (2009) Structural Bioinformatics, an algorithmic approach, CRC Press
# Rex A Dwyer (2002) Genomic Perl, Cambrige University Press

use strict;

## 0) parametros del algoritmo: 
my %HBonds  = ( 'GU'=&gt;-1, 'UG'=&gt;-1, 'AU'=&gt;-2, 'UA'=&gt;-2, 'CG'=&gt;-3, 'GC'=&gt;-3 ); # puentes H en ~kcal/mol
my $MINSEP  = 3; # min separacion en secuencia para definir un par de bases: un loop contiene 3+ bases
my $MINSTEM = 2; # longitud minima de region complementaria para tallos bifurcados
my $DEBUG   = 1; 

print "# params: MINSEP=$MINSEP MINSTEM=$MINSTEM DEBUG=$DEBUG\n\n";

# 0.1) secuencia de RNA de partida, comenta  
my $RNA = 'GCUCAAAGUATACCAGGAGG'; #'CCCCUUUUGGGG'; 'CUGUCUGUCUUGAGACA'; 'GCUCAAAGUATACCAGGAGG';

## 1) rellena la matriz o tabla de programacion dinamica
my @matriz_align = prog_dinamica( $DEBUG, $MINSEP, $MINSTEM, \&amp;evalfunc, $RNA );

## 2) muestra energia libre de la estructura secundaria encontrada
print "# energia libre derivada del alineamiento = ".$matriz_align[1][length($RNA)]{'matriz'}." kcal/mol\n";

## 2) calcula el mejor camino o alineamiento
print "$RNA\n" . reconstruye_alineamiento(1,length($RNA),\@matriz_align) . "\n";

###############################################################################

# devuelve un entero
# funcion que evalua un par de bases recurriendo al hash global %HBonds
sub evalfunc 
{
	my ($par) = @_;
	return $HBonds{$par} || 0; 
}

# devuelve @alignmat[][]{}, con llaves 'eval','matriz','caso','k'
sub prog_dinamica 
{
	my ($print_matrix,$minsep,$minstem,$ref_funcion_eval,$secuencia) = @_;  
	
	my $long = length($secuencia); 
	my @sec = (' ', split(//, $secuencia)); # primera posicion vacia ' ' para contar desde 1
	my ($l,$i,$j,$k,$par,$bonds,$min,$minbif,$caso1,$caso2,$caso3,$caso4,@matriz,@alignmat);
	
	# 1) inicia la matriz marcando la diagonal de pares prohibidos &lt; $minsep
	for $i (1 .. $long-$minsep){ $matriz[$i][$i+$minsep] = 0; } 
	
	# 2) inicia la primera diagonal permitida
	for $i (1 .. $long-$minsep-1)
	{ 
		$par = $sec[$i].$sec[$i+$minsep+1]; 
		$matriz[$i][$i+$minsep+1] = $ref_funcion_eval-&gt;($par);  
		$alignmat[$i][$i+$minsep+1]{'eval'} = $ref_funcion_eval-&gt;($par); 
		$alignmat[$i][$i+$minsep+1]{'caso'} = 1; 
	}	

	# 3) rellena recursivamente $long-5 diagonales restantes en la matriz de prog dinamica
	# $i extremo izquierdo, $j extremo derecho 
	for $l (5 .. $long-1)
	{
		for $i (1 .. $long-$l) 
		{
      $j = $i+$l; 
			$par = $sec[$i].$sec[$j]; 
			$bonds = $ref_funcion_eval-&gt;($par); 
			$alignmat[$i][$j]{'eval'} = $bonds; 
			$min = 100;
			
			# 3.1) prueba las 4 situaciones posibles dados i,j
			$caso1 = $matriz[$i+1][$j-1] + $bonds; # 1: nuevo par de bases alineados
			
			$caso2 = $matriz[$i+1][$j]; # 2: gap en un extremo, se conserva evaluacion anterior
			$caso3 = $matriz[$i][$j-1]; # 3: gap en extremo opuesto, se conserva evaluacion
							       #      (observa que no hay gap penalty)
			
			$caso4 = 100;               
      if($j &gt; $i+3+($minstem*2))  # 4: bifurcacion en base k si hay distancia suficiente            
			{     
				# ._i k_.-._. j_.                      i____k.....j
				#   . .     . .                         ...........
				#   . .      *                           .......... 
				#    *                                    .........
				#                                          ........
				#                                           .______
				#                                            ......
				#                                             .....
				#     (*=loop de $minsep)                      ....
				#                                               ...
				#                                                ..
				#                                                 .
				for $k ($i+2+($minstem*2) .. $j-3-($minstem*2))
				{
					$minbif = $matriz[$i][$k] + $matriz[$k+1][$j];
					if($minbif &lt; $caso4)  
					{
						$caso4 = $minbif;
						$alignmat[$i][$j]{'k'} = $k;
					}	
				}
	   	} 
			
			# 3.2) elige la mejor en esta posicion, actualizando $min
			if($caso1 &lt; $min &amp;&amp; $bonds &lt; 0)
			{
				$min = $caso1;
				$alignmat[$i][$j]{'caso'} = 1;
			}
			if($caso2 &lt; $min)
			{
				$min = $caso2;
				$alignmat[$i][$j]{'caso'} = 2;
			}
			if($caso3 &lt; $min)
			{
				$min = $caso3;
				$alignmat[$i][$j]{'caso'} = 3;
			}
			if($caso4 &lt; $min)
			{
				$min = $caso4;
				$alignmat[$i][$j]{'caso'} = 4;
			}
			
			# 3.3) anota la opcion mas favorecida en esta posicion
			$matriz[$i][$j] = $min;
			$alignmat[$i][$j]{'matriz'} = $min; 
		}
    }
	
	# 4) imprime la matriz si se require
	if($print_matrix)
	{
		for $i (1 .. $long)
		{
			for $j (1 .. $long)
			{ 
				$bonds = $matriz[$i][$j] || 0; 
				if($i == $j){ $bonds = $sec[$i] }
				elsif($i==$long){ $bonds = $j }
				elsif($j==1){ $bonds = $i }
				elsif($j-$i &lt;= $minsep){ $bonds = '.' }
				printf("%4s",$bonds);
			}print "\n";
		}print "\n";	
	}
	
	return @alignmat;
}

# Devuelve una cadena de caracteres que codifican un alineamiento o estructura secundaria con pares
# alineados marcados como ()
sub reconstruye_alineamiento
{
	my ($i,$j,$ref_align_matrix) = @_;  # i,j coordenadas en la matriz $ref_align_matrix

	my $caso = $ref_align_matrix-&gt;[$i][$j]{'caso'} || 0;

   if($caso == 1)
	{ 
		return '(' . reconstruye_alineamiento($i+1,$j-1,$ref_align_matrix) . ')';
	}
	elsif($caso == 2)
	{ 
		return '.' . reconstruye_alineamiento($i+1,$j,$ref_align_matrix);
	}
	elsif($caso == 3)
	{ 
		return reconstruye_alineamiento($i,$j-1,$ref_align_matrix);
	}
	elsif($caso == 4)
	{ 
		my $k = $ref_align_matrix-&gt;[$i][$j]{'k'}; 
		return reconstruye_alineamiento($i,$k,$ref_align_matrix) . 
			reconstruye_alineamiento($k+1,$j,$ref_align_matrix);
	}
	else{ return ' ' x ($j-$i+1); }
}
</PRE>
<P>

<DIV ALIGN="CENTER"><A NAME="fig:RNAdotplot"></A><A NAME="2651"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figura 4.2:</STRONG>

Estructura secundaria de una mol&#233;cula de RNA y matriz (dot plot) que esquematiza sus puentes de hidr&#243;geno.
Figura tomada de <A
 HREF="node50.html#Bernhart2006">Bernhart <EM>et&nbsp;al.</EM> (2006)</A> y reproducida con permiso. 
</CAPTION>
<TR><TD>
<DIV ALIGN="CENTER">
<IMG
  WIDTH="600" HEIGHT="386" ALIGN="BOTTOM" BORDER="0"
 SRC="./RNAdotplot.jpg"
 ALT="Image RNAdotplot">

</DIV></TD></TR>
</TABLE>
</DIV>


<DIV CLASS="navigation"><hr> 
<A NAME="tex2html999"
  HREF="node29.html">
<IMG  ALIGN="BOTTOM" BORDER="0" ALT="previous"
 SRC="./icons//prev.png"></A> 
<A NAME="tex2html1005"
  HREF="node29.html">
<IMG  ALIGN="BOTTOM" BORDER="0" ALT="up"
 SRC="./icons//up.png"></A> 
<A NAME="tex2html1007"
  HREF="node31.html">
<IMG  ALIGN="BOTTOM" BORDER="0" ALT="next"
 SRC="./icons//next.png"></A> </DIV>
<!--End of Navigation Panel-->
<ADDRESS>
<a href="http://hdl.handle.net/10261/21892">PDF</a><br>Contreras-Moreira,B. (2018) Algoritmos en bioinform&aacute;tica estructural. <a href="https://doi.org/10.20350/digitalcsic/8544">doi:10.20350/digitalcsic/8544</a><br><a href="http://www.eead.csic.es/compbio">http://www.eead.csic.es/compbio</a>
</ADDRESS>
</BODY>
</HTML>
