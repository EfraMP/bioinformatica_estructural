<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<!--Converted with LaTeX2HTML 2008 (1.71)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Protein fold recognition </TITLE>
<META NAME="description" CONTENT="Protein fold recognition ">
<META NAME="keywords" CONTENT="algoritmos3D">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META NAME="Generator" CONTENT="LaTeX2HTML v2008">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="algoritmos3D.css">

<LINK REL="next" HREF="node34.html">
<LINK REL="previous" HREF="node32.html">
<LINK REL="up" HREF="node30.html">
<LINK REL="next" HREF="node34.html">
<!--google-->
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-22456715-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>
</HEAD>

<BODY >

<DIV CLASS="navigation">
<A NAME="tex2html896"
  HREF="node32.html">
<IMG  ALIGN="BOTTOM" BORDER="0" ALT="previous"
 SRC="./icons//prev.png"></A> 
<A NAME="tex2html902"
  HREF="node30.html">
<IMG  ALIGN="BOTTOM" BORDER="0" ALT="up"
 SRC="./icons//up.png"></A> 
<A NAME="tex2html904"
  HREF="node34.html">
<IMG  ALIGN="BOTTOM" BORDER="0" ALT="next"
 SRC="./icons//next.png"></A> <div><fieldset>Siguiente: <b><A NAME="tex2html905"
  HREF="node34.html">Modelado de prote&#237;nas por homolog&#237;a</A></b>  Arriba: <b><A NAME="tex2html903"
  HREF="node30.html">Estructura terciaria</A></b>  Anterior: <b><A NAME="tex2html897"
  HREF="node32.html">Comparaci&#243;n de estructura terciaria entre</A></b></fieldset></div></DIV>
<!--End of Navigation Panel-->

<H1><A NAME="SECTION00530000000000000000">
 <i> Protein fold recognition  </i></A>
</H1>

<P>
Al analizar secuencias gen&#243;micas frecuentemente encontraremos marcos de lectura (te&#243;ricos) que codifican para prote&#237;nas que aparentemente no se parecen a ninguna otra (llamadas a veces  <i> orphans  </i> en la literatura), 
o que s&#243;lo tienen similitudes obvias con prote&#237;nas de funci&#243;n desconocida. Esto puede deberse a que de veras son 
mol&#233;culas observadas por primera vez, o como vimos en <A HREF="node31.html#3dcons">5.1</A>, a que la evoluci&#243;n ha conservado en mayor grado
la estructura y topolog&#237;a de las prote&#237;nas hom&#243;logas que sus secuencias. 

<P>
La segunda posibilidad ha justificado una familia de m&#233;todos llamados gen&#233;ricamente de  <i> Fold Recognition  </i> (FR), que tienen como objeto reconocer a qu&#233; tipo de plegamiento (de los conocidos) se debe asignar una secuencia problema, especialmente cuando b&#250;squedas m&#225;s convencionales con 
<A NAME="tex2html239"
  HREF="http://blast.ncbi.nlm.nih.gov/Blast.cgi">BLAST</A>
o 
<A NAME="tex2html240"
  HREF="http://www.ebi.ac.uk/Tools/fasta/index.html">FASTA</A>
han fracasado.
Hist&#243;ricamente algunos de estos m&#233;todos se han llamado de
<A NAME="tex2html241"
  HREF="http://en.wikipedia.org/wiki/Threading_%28protein_sequence%29"> <i> threading  </i></A>, 
ya que ciertos algoritmos 
literalmente enhebran la secuencia problema en patrones de coordenadas conocidas, normalmente un subconjunto no redundante
del PDB, para ver si es compatible con alguno. 

<P>

<DIV ALIGN="CENTER"><A NAME="fig:threading"></A><A NAME="2658"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figura 5.5:</STRONG>

Figura tomada de <A NAME="tex2html236"
  HREF="http://www.bioscience.org">http://www.bioscience.org</A>
</CAPTION>
<TR><TD>
<DIV ALIGN="CENTER">
<IMG
  WIDTH="596" HEIGHT="438" ALIGN="BOTTOM" BORDER="0"
 SRC="./threading.jpg"
 ALT="Image threading">

</DIV></TD></TR>
</TABLE>
</DIV>

<P>
El problema de FR lo podemos plantear as&#237;:

<UL>
<LI><SPAN  CLASS="textbf">PROBLEMA:</SPAN> conocemos la secuencia de una prote&#237;na, pero desconocemos su tipo de plegamiento y su funci&#243;n
</LI>
<LI><SPAN  CLASS="textbf">SOLUCI&#211;N PROPUESTA:</SPAN> comparar la secuencia con todos los plegamientos conocidos, calcular el grado de parecido/compatibilidad con cada uno de ellos y devolver una lista ordenada
</LI>
</UL>

<P>
Se han publicado muchas maneras diferentes de hacer FR:

<UL>
<LI>por medio de b&#250;squedas BLAST bidireccionales transitivas (<A
 HREF="node44.html#Koretke2002">Koretke <EM>et&nbsp;al.</EM>, 2002</A>)
</LI>
<LI>representando cada  <i> fold  </i> por medio de las secuencias conocidas que se pliegan en esa conformaci&#243;n, 
ya sea por medio de perfiles (<A
 HREF="node44.html#Gribskov1987">Gribskov <EM>et&nbsp;al.</EM>, 1987</A>)
o <A NAME="tex2html242"
  HREF="http://en.wikipedia.org/wiki/Hidden_Markov_model">modelos de Markov</A>
</LI>
<LI>con alineamientos secuencia-perfil o los m&#225;s sensibles perfil-perfil (<A
 HREF="node44.html#Soding2005">Soding, 2005</A>) que son la raz&#243;n del &#233;xito del servidor <A NAME="tex2html243"
  HREF="http://toolkit.tuebingen.mpg.de/hhpred">HHpred</A>
</LI>
<LI>usando potenciales estad&#237;sticos para evaluar la cercan&#237;a de los residuos de una secuencia
dado un plegamiento (lo que llamamos  <i> threading  </i> (<A
 HREF="node44.html#Threader1992">Jones <EM>et&nbsp;al.</EM>, 1992</A>)) </LI>
<LI>combinando diferentes moldes, alineamientos y algoritmos en estrategias de b&#250;squeda de consenso, 
con la ayuda de m&#233;tricas fiables como <A NAME="tex2html244"
  HREF="http://www.ncbi.nlm.nih.gov/pmc/articles/PMC2040163/">3D-Jury</A>
(<A
 HREF="node44.html#Ginalski2003">Ginalski <EM>et&nbsp;al.</EM>, 2003</A>)
</LI>
<LI>partiendo la secuencia problema en fragmentos, como una estrategia divide y vencer&#225;s, buscando la estructura
mas probable para cada fragmento por  <i> threading  </i> (<A
 HREF="node44.html#Wu2010">Wu &amp; Zhang, 2010</A>)
</LI>
</UL>

<P>
Probablemente la mejor manera de evaluar objetivamente y elegir un m&#233;todo de FR son los experimentos  
<A NAME="tex2html245"
  HREF="http://predictioncenter.org/index.cgi?page=public_serv">CASP</A>,
que miden peri&#243;dicamente la competencia de los diferentes algoritmos. 

<P>
Estas herramientas web son adecuadas para estudiar unas pocas secuencias, pero si queremos hacer un experimento de FR 
a gran escala, entonces buena idea instalar localmente el software elegido, como por ejemplo
<A NAME="tex2html246"
  HREF="https://github.com/soedinglab/hh-suite">hh-suite</A>, el software que da vida a 
<A NAME="tex2html247"
  HREF="http://toolkit.tuebingen.mpg.de/hhpred">HHpred</A>.

<P>
El siguiente programa es un prototipo de alineamiento perfil-perfil que usa adem&#225;s predicciones de estructura secundaria (ver figura <A HREF="node29.html#fig:psipred">4.7</A>) 
para guiar el alineamiento. Es un algoritmo de programaci&#243;n din&#225;mica, que puedes comprender mejor con ayuda 
del <A NAME="tex2html248"
  HREF="http://protein.bio.puc.cl/websoftware/web/?sid=3"> <i> Sequence Alignment Teacher  </i></A>
(<A
 HREF="node44.html#Ibarra2010">Ibarra &amp; Melo, 2010</A>).

<P>
Para probarlo necesitaras descargar los archivos de entrada
(<A NAME="tex2html249"
  HREF="./files/1ngk_A.pssm">1ngk_A.pssm</A>,<A NAME="tex2html250"
  HREF="./files/1s69_A.pssm">1s69_A.pssm</A>,
<A NAME="tex2html251"
  HREF="./files/1ngk_A.psipred">1ngk_A.psipred</A>,<A NAME="tex2html252"
  HREF="./files/1s69_A.psipred">1s69_A.psipred</A>):
<BR>
<PRE  CLASS="verbatim">#!/usr/bin/perl -w

# programa 3.2 algoritmo de alineamiento global perfil-perfil
# Bruno Contreras-Moreira

use strict;

my %AAORDER = ('A',1,'R',2,'N',3,'D',4,'C',5,'Q',6,'E',7,'G',8,'H',9,'I',10,'L',11,
		'K',12,'M',13,'F',14,'P',15,'S',16,'T',17,'W',18,'Y',19,'V',20);
my $GAPCOST = -8; # coste de un gap 
my $SSBONUS = 2;  # premio por igual estructura secundaria

## -1) archivos de entrada
my $perfil1 = './files/1ngk_A.pssm'; # perfil generado con PSI-BLAST
my $perfil2 = './files/1s69_A.pssm'; 
my $SS1     = './files/1ngk_A.psipred'; # estructura secundaria predicha con PSIPRED
my $SS2     = './files/1s69_A.psipred'; 

print "# $0 input: $perfil1 $perfil2 $SS1 $SS2 params: $GAPCOST $SSBONUS\n\n";

## 0) define variables y lee perfiles 
my ($ID,$total,$gaps,@matrix,$l1,$l2,$i,$j,$aa1,$aa2,$par) = (0,0,0);
my ($align1,$align2,$ss1,$ss2,$ruler,$gapi,$gapj,$score) = ('','','','','');

my ($seq1,@perfil1) = lee_perfil($perfil1);
my ($seq2,@perfil2) = lee_perfil($perfil2);
my @SS1 = lee_SS($SS1);
my @SS2 = lee_SS($SS2);

$l1 = length($seq1);
$l2 = length($seq2); 

## 1) define e inicia matriz de programacion dinamica
# http://es.wikipedia.org/wiki/Algoritmo_Needleman-Wunsch
for($j=0;$j&lt;=$l1;$j++){ $matrix[0][$j]{'score'} = $j * $GAPCOST; }
for($i=0;$i&lt;=$l2;$i++){ $matrix[$i][0]{'score'} = $i * $GAPCOST; }

## 2) rellena la matriz fila a fila
for($i=1;$i&lt;=$l2;$i++) 
{
	for($j=1;$j&lt;=$l1;$j++) 
	{
        	$score = evalua_par($perfil1[$j-1],$perfil2[$i-1]);
		if($SS1[$j-1] eq $SS2[$i-1] &amp;&amp; $SS2[$i-1] ne 'C'){ $score += $SSBONUS }
		
		# calcula 3 posibles scores: diagonal y gaps
        	$par = $matrix[$i-1][$j-1]{'score'} + $score;
        	$gapi = $matrix[$i-1][$j]{'score'} + $GAPCOST;
        	$gapj = $matrix[$i][$j-1]{'score'} + $GAPCOST;
		
		($matrix[$i][$j]{'score'},$matrix[$i][$j]{'dir'}) = max($par,$gapi,$gapj);
	}
}

## 3) reconstruye alineamiento
($i,$j) = ($l2,$l1); 
$score = $matrix[$i][$j]{'score'};

while (1) 
{
    last if(!$matrix[$i][$j]{'dir'});
     
    if ($matrix[$i][$j]{'dir'} eq 'diagonal') 
    {
    	$i--; $j--;
	$aa1 = substr($seq1,$j,1);
	$aa2 = substr($seq2,$i,1);
        $align1 = $aa1 . $align1;
        $align2 = $aa2 . $align2;
	$ss1    = $SS1[$j] . $ss1;
	$ss2    = $SS2[$i] . $ss2;
	if($aa1 eq $aa2)
	{ 
		$ID++; 
		$ruler = '|' . $ruler;
	}
	else{ $ruler = ' ' . $ruler; }
	$total++;
    }
    elsif($matrix[$i][$j]{'dir'} eq 'gapj') 
    {
        $align1 = substr($seq1,$j-1,1) . $align1;
        $align2 = '-' . $align2;
	$ss1    = $SS1[$j-1] . $ss1;
	$ss2    = '-' . $ss2;
	$ruler = ' ' . $ruler;
        $j--;
    }
    else 
    {
        $align1 = '-' . $align1;
        $align2 = substr($seq2,$i-1,1) . $align2;
	$ss1    = '-' . $ss1;
	$ss2    = $SS2[$i-1] . $ss2;
	$ruler = ' ' . $ruler;
        $i--;
	$gaps++; # en secuencia1
    }   
}

print "# identical aligned residues = $ID/$total gaps = $gaps score = $score\n";
print "$perfil1\n$ss1\n$align1\n$ruler\n$align2\n$ss2\n$perfil2\n";

#####################################################

# lee fichero PSSM generado por PSI-BLAST con opcion -Q
sub lee_perfil
{
	my ($PSSMfile) = @_;
	 
	my ($secuencia,@perfil,$col,$aa,$weights) = ('');

        # 1 K   -4  2 -3 -3 -6  6  1 -5 -3 -6 -5  4 -4 -6  5 -3 -4 -6 -5 -5     
	open(PSSM,$PSSMfile) || die "# lee_perfil: no puedo leer $PSSMfile\n";
	while(&lt;PSSM&gt;)
	{
		if(/^\s+(\d+)\s+(\w)\s+(.+?)\n/)
		{
			($col,$aa,$weights)=($1,$2,$3); 
			$col -= 1; # cuenta desde 0
			push(@{$perfil[$col]},$aa); # posicion 0: secuencia
			push(@{$perfil[$col]},(split(/\s+/,$weights))); # pos 1..20: pesos
			$secuencia .= $aa;
		}
	}
	close(PSSM);

	return ($secuencia,@perfil);    
}
    
# evalua una pareja de aminoacidos consultando su vector de pesos/sustituciones
# usa global: %AAORDER
sub evalua_par
{
	my ($pssv1,$pssv2) = @_;
	
	my $score1 = $pssv2-&gt;[$AAORDER{$pssv1-&gt;[0]}];
	my $score2 = $pssv1-&gt;[$AAORDER{$pssv2-&gt;[0]}];
	return sprintf("%1.2f",($score1+$score2)/2);
}

# lee fichero de prediccion de estructura secundaria generado con PSIPRED
sub lee_SS
{
	my($SSfile) = @_;
	
	my (@SS);

	#Pred: CCHHHHHCCHHHHHHHHHHHHHHHHCCHHHHHHCCCCCHHHHHHHHHHHHHHHHCCCCCC
	open(PSIPRED,$SSfile) || die "# lee_SS: no puedo leer $SSfile\n";
	while(&lt;PSIPRED&gt;)
	{
		if(/^Pred: (\w+?)\n/){ push(@SS,(split(//,$1))); }
	}
	close(PSIPRED);

	return (@SS);    
}	

sub max
{
	my ($par,$gapi,$gapj) = @_;
	
	if($gapi&gt;$gapj &amp;&amp; $gapi&gt;$par){ return($gapi,'gapi'); }
	elsif($gapj &gt;= $par &amp;&amp; $gapj &gt;= $gapi){ return($gapj,'gapj'); }
	else{ return($par,'diagonal'); }
}            		
</PRE>
<DIV CLASS="navigation"><hr> 
<A NAME="tex2html896"
  HREF="node32.html">
<IMG  ALIGN="BOTTOM" BORDER="0" ALT="previous"
 SRC="./icons//prev.png"></A> 
<A NAME="tex2html902"
  HREF="node30.html">
<IMG  ALIGN="BOTTOM" BORDER="0" ALT="up"
 SRC="./icons//up.png"></A> 
<A NAME="tex2html904"
  HREF="node34.html">
<IMG  ALIGN="BOTTOM" BORDER="0" ALT="next"
 SRC="./icons//next.png"></A> </DIV>
<!--End of Navigation Panel-->
<ADDRESS>
<a href="http://hdl.handle.net/10261/21892">PDF</a><br>Bruno Contreras-Moreira<br><a href="http://www.eead.csic.es/compbio">http://www.eead.csic.es/compbio</a>
</ADDRESS>
</BODY>
</HTML>
